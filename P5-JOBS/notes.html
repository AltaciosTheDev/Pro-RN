<!-- 
CONCEPT RECAP
    1)jsx
    2)fragments
    3)components
    4)props
    5)event handlers
    6)hooks
    7)shortcuts (rfc)
    8)useState - renders 
    9)useEffect - side effects 
    10)() return several lines
    11)`` ${} template literals
    12)return -> exit from function 
    13)... -> spred operator
    14)&& short circuiting 
    15)style={{fontStyle="50px"}}
    16)every component could import its own css file 
    17)let,var,const
    18)controlled input

SIMPLE LOGGIC BEHIND LOADING A WEB PAGE
    1)client requests url to server
    2)server serves the index.html
    3)index.html links to all the static files(fonts, images, stylesheets,favicon)
    4)client will make network request for all those static files

NEW KNOWLEDGE
    1)arrow funcs need to be exported at the end of the file
    2)"react/prop-types":"off"

PROJECT 1 - FANCY COUNTER
    CREATE PROJECT WITH VITE
        npm create vite@version
        npm install
        npm run dev

    PAKCHAGE JSON
        All important information about the project(versions, commands, dependencies)

    ESLINT
        Can install extension but config file will take precedence.

    HOW CAN PEOPLE GET NODE_MODULES
        npm install
            installs dependencies on the package.json
        .gitignore
            holds the node_modules so they are not commited or shared

    WHERE TO STORE IMAGES
        src
            assets
                if they are referenced
        public
            if they are not referenced

    AUTO IMPORTS
        ctrl+enter -> should pop up intellisense

PROEJECT 2 - WORD ANALYTICS
    TO LEARN
        Character analyzer to see how many characters are left in a post for social media.
    
    CREATE PROJECT
        npm create vite@version . 

    TRIIGGER INTELLISENSE
        ctrl + space
        enter

    REMEMBER SEMANTIC HTML
        <header>
        <footer>
        <main>
        <section>

    REMEMBER RETURN
        return from negative paths to prevent rest of code to execute
        
    DON'T NEED TO ADD MORE STATE
        Analyze if states are very closely related and eliminate one. 
        Boolean state is not necessary, we can condition with trushy and falsy states.
    
    DERIVED STATE
        Calculations based on an existing state.
        Avoids overpopulating with more states.

    LIFTING STATE UP 
        To parent component that can distribute to all children in need.

    PASSING PROPS AS DESTRUCTURED OBJECT
        Passing a lot of props gets messy and tedious.

        const stats = {
            numberOfWords: text.split(/\s/).filter((word) => word !== "").length,
            numberOfCharacters: text.length,
            instagramCharactersLeft: 280 - text.length,
            facebookCharactersLeft: 2200 - text.length,
        };

        <Stats
            {...stats}
        />

    CONDITIONAL STYLING IN REACT
        className={`original clases ${var ? "classToRender" : ""}`}

    EXTRACTING CONSTANTS IN SEPARATE FILE
        Every single constant value, in separate constants.js file.
        
        EXAMPLE
            export const INSTAGRAM_MAX_CHARACTERS = 280
            export const FACEBOOK_MAX_CHARACTERS = 280
    
    FOLDER STRUCTURE
        paths must be relative to the main.jsx

        COMPONENTS
            all react components
        LIB
            constants
            hooks
            utilites

INTERMEDIATE REACT & JAVASCRIPT
    ARRAYS - INTERMEDIATE
        push
        length
        .forEach
        item[#]
    OBJECTS - INTERMEDIATE
        nested objects
        property shorthands
    ARRAYS - ADVANCED
        .push()
        .map() - returns new array - always specify return keyword
        .some() - returns true if at least 1 element fulfills condition - always specify return keyword
        .find() - returns 1st element or undefined - always specify return keyword
        .filter() - returns new array with elements that specify condition - always specify return keyword
    
    OBJECTS - ADVANCED
        bracker notation 
            object[property]
    SPREAD OPERATOR
        const totalArry = [...arr, ...arr2]
    DESTRUCTURING
        const {name} = user -> must be same name
        const [anything] = cart -> order is what matters
    PRIMITIVES VS REFERENCES
        only primitives can be compared(== || ===)
        reference -> you get pointers to where the data is stored -> thats why they can't be compared
    SHORT CIRCUITING && --
        && -> super consice if this is true, run the right part.
        || -> if first is true, stop there. If first is false, run second.
    FUNCTIONS - INTERMEDIATE
        order of execution 
        refactoring -> get rid of redundant code always
        early return -> stops function execution
    FUNCTIONS - ADVANCED
        callbacks -> function as parameter
        method -> function on something
            this keyword only works on traditional function (not arrows)
        default param
            could avoid undefinde in a math operation
    FETCH - INTRO
        words we can type without error are browser included:
            fetch()
        json -> syntad used by client - server communication 
            readable
            supported by most prog-langs
        .then()
            handles a promise -> must return 
        .catch()
            handles errors from the server
        if(!res.ok) -> method that comes with fetch promise -> indicates if response status is in the 200s. This is necessary b/c .catch won;t always catch all errors.
        
    ASYNC - AWAIT
        More modern syntax

        try{
            res = await fetch 
            data = await res
        }
        catch{
            errror
        }

    CUSTOM HOOKS
        Functions that incorporate default hooks + additional logic

        WHERE TO PUT
            hooks folder
                specific hook file

    RULES OF HOOKS
        NOT IN 
            loops
            conditions
            nested functions
            after early return statement

PROJECT 3 - TREKBAG 
    FEATURES
        add items in form (done)
        delete items (done)
        check items (done )
        sort
            pack
            unpacked
            default 
        reset to initial (done)
        mark all as complete(done)
        mark all as incomplete(done)
        remove all items(done)
        localstorage for data persistence
        counter

    TO LEARN
        context api
        zustand
    
    ESLINT
        Pop linting tool for js and ts. 
        Finds potential bugs by analyzing files and flagging issues based on predefined or custom rules.

    ESLINT-PLUGIN-REACT
        specifically for react.
        same as normal eslint but related to react and jsx.
    ESLINT-PLUGIN-REACT-HOOKS
        enforces rules of react hooks.
        ensures popular hooks are used correctly following react guidelines.

    LOOP
        ALWAYS loop when you are repeating your code.
    
    STATIC DATA
        If in file, store outside component definition

    EMOJI POP UP MODAL
        windows + . 
    
    NEW DATE().GETTIME()
        Can be used as a substitute for an id in an object in a database

    useRef()
        Hook to literally hook in a ref for an element in the browser.
        useEffect()

    TOAST instead of ALERTS
        more professional

    IMPLEMENTATION LOGIC AND STATE IN 1 PLACE
        Standard practice to keep in 1 place:
            state
            derived state
                normal arithmetic logic on existing state
            logic handlers

    onEvent - onHandleEvent
        When the prop reaches the component that will make use of it,change naming to onEvent to keep html standards.

    SORTING
        1)place component
            React-Select Library
                Represents a whole new approach to developing powerful React.js components that just work out of the box, while being extremely customisable.
        2)Set props
            onChange
            options
            setDefaultValue
        3)make UI change depending on the sortState
            create sort state
            sort array
            map sorted array 
    
    LOCALSTORAGE
        Store items
        UseEffect
        initialize state with return from lc || initial data if lc empty

    USEMEMO
        hook in react to avoid doing recalculation by storing a computation in memory until dependencies change. 
        Same useEffefcct syntax


    CHILDREN COMPOSITION
        Pretty much just move the components higher and bloat up higher to avoid prop drilling.

    CONTEXT
        Hook that allows for the transport of information. 

        1)CREATE CONTEXT COMPONENT
            <ItemsContextProvider>
            1.1)Outside that component definition createContext
                const ItemsContext = createContext()

            1.2)return the context.provider
                return(
                    <ItemsContext.Provider value={{objWithData}}>{children}</ItemsContext.Provider>
                )
        2)WRAP ELEMENTS WITH CONTEXT
            <ItemsContextProvider>
                <everything else>
            </ItemsContextProvider>
        3)export and consume the context from somewhere
            1)export it from the file where it was created
                export ItemsContext = createContext()
            2)consume it
                const {this,that} = useContext(ItemsContext)

        PROBLEMS
            No selectors, meaning every component attached to a part of context will always render if 1 of them change. 
            Big apps will need A LOT of context providers. That will mean a lot of boilerplate code and wrapping of components. 
            Middleware and advanced, context is limited. 
            

    CUSTOM HOOKS
        Regular js function that encompasses and makes use of a hook.

        STRUCTURE
            lib
                hook.js

        EXAMPLE
            export function useItemsContext() {
                const context = useContext(ItemsContext)

                if(!context) {
                    throw new Error
                }
                return context
            }
        BENEFITS
            1 import instead of 2(useContext, itemsContext)
            easier to write useItemsContext() instead of useContext(ItemsContext)
            when using typescript will have to account for situation in which context returns nothing.This logic can be handled here
        
        
    ZUSTAND 
        State management library for react providing simple, lightweight, flexible alternative to redux. 

        BENEFITS
            ease of use
            minimal boilerplate
            powerful capabilities

        WHY IT WORKS WELL
            simplicity
                intuitive and no strict pattern
            performance 
                no unnecessary re-renders
            no context provider hell
                no context api use, so no context provider hell
            versatility
                supports both local and global state management, suitable for different scale applications
            merging of state
                dont have to spread the store object, only the modified part will be changed.
                No need to specify {...store, propToChange: newValue}

        INSTALL 
            npm install zustand

        WHERE
            stores(folder)
                itemsStore.js/ts

        HOW
            Creates a store for managing state. 

            1)store creation
                create function to define state and actions.  

                import create from 'zustand'
            
                const useStore = create((set) => {
                    bears:0,
                    increasePopulation: () => set((state) => ({bears: state.bears + 1})) -> previous State needed, set receives it as parameter
                    removeAllBears: () => set({bears: 0})                                -> no prev state needed, just replace the state.
                    updateBears: (newBears) => set({bears: newBears})                    -> payload from outside needed. Main function receives as param. 
                })
            *)export store
                const export useItemStore = create((set) => ({store}))

            2)accessing the store 
                inside component
                    const bears = useStore((state) => state.bears)
                    const increasePopulation = useStore((state) => state.increasePopulation)

            3)state update
                zustand uses "set" function to update state. 
                Reactive updates: only parts using the affected parts will re render.
            4)middleware support
                supports middleware like extending state or logging changes.
            
        ADVANCED FEATURES
            1)selectors
                derived state
                pick specific parts of the store
            2)middleware
                you can enhance the store with middleware for logging, persistance or async actions.

        WHEN
            small - medium sized applications
            simple alternative to redux
            global state managemnt NO boilerplate
            avoiding limits of context API

        WHERE ZUSTAND SHINES
            NO PROVIDER COMPONENT HELL
            NO UNNECESARY RE RENDER
            NO NEED TO SPREAD STATE, MORE DECLARATIVE PROGRAMMING
            SIMPLE TO SET AND USE
            SMALL,MID,LARGE PROJECTS 
            AVANCED MIDDLEWARE like persist for localstorage
            
TYPESCRIPT IN REACT
    IN COMPONENT PROPS:
        MAINTAINS CONSISTENCY IN PROPS GIVEN AND NEEDED
            Instance
                Given props not defined in component definition will return error.
                    Property 'pillshape' does not exist on type 'IntrinsicAttributes & ButtonProps'
                Missing props defined but not given will remind the user they are needed.
                   Type '{}' is missing the following properties from type 'ButtonProps': backgroundColor, fontSize, pillShapets(2739)

            Definition
                Defined props not used, will return error.
                    'backgroundColor' is defined but never used
            
            INTELLISENSE
                ctrl+space
                    Ts will show all the possible props that the component is expecting

        DEFINING PROP TYPES
            Since prop is an object, prop types will be for objects.

            SYNTAX 1 - INLINE
                export default function Button({backgroundColor,fontSize pillShape}:{backgroundColor:string, fontSize:number, pillShape: boolean}) {
                    return (
                        <button>
                            ...
                        </button>
                    );
                }

            SYNTAX 2 - EXTRACTED PROP TYPE
                Declare type outside of component definition

                type ButtonProps = {backgroundColor:string, fontSize:number, pillShape: boolean}

                export default function Button({backgroundColor,fontSize, pillShape}:ButtonProps) {
                    return (
                        <button className="bg-blue-500 text-white rounded px-4 py-2">
                        Click me
                        </button>
                    );
                }

                EXTRACTED UNION TYPE FOR ALREADY EXTRACTED PROP TYPE
                    type Color = "red" | "blue" | "green"
                    type ButtonProps = {backgroundColor: Color, fontSize:number, pillShape: boolean}


        OPTIONAL PROP 
            type ButtonProps = {backgroundColor:string, fontSize:number, pillShape?: boolean}

        ARRAY TYPE FOR PROP
            type ButtonProps = {backgroundColor: Color[], fontSize:number, pillShape: boolean, padding: number[]}

        TUPLE TYPE FOR PROP
            Will determine:
                1)specific number of elements
                2)type of each specific element

            type ButtonProps = {backgroundColor: Color[], fontSize:number, pillShape: boolean, padding: [number, number, number]}
            <Button padding: [44,33,22]/> -> only 3 elements b/c that is what is defined in the tuple 

        USING AND OBJECT FOR STYLE INSTEAD OF INDIVIDUAL PROPERTIES
            MANUAL 
                type ButtonProps = {
                    style: {
                        backgroundColor: string,
                        fontSize: number
                        etc
                    }
                }

                <Button style={{backgroundColor: "blue", fontSize: 24}}/>
            
            REACT CSS PROPERTIES TYPE
                type ButtonProps = {
                    style: React.CSSProperties
                }

                WHY?
                    Permits use to pass an object filled with actual css properties in the component instance AND AVOID writing all of them in the type created, b/c this is already done by React.
                    Will tell you if you wrote incorrectly a property in the instance, since it will not exist in the interface created by react
                    Will tell you if the value you wrote is incorrect, since it is already defined in he interface what values are permited.

        GENERICS IN PROP TYPES
            type ButtonProps = {
                borderRadius: Record<string, number>
            }

            <Button borderRadius={{
                topLeft: 5,
                topRight: 5, 
                bottomRight:10,
                bottomLeft:10
            }}/>

        TYPES FOR FUNCTION PROPS
            Create and pass the function
                const onClick = (test:string) => 5
                <Button onClick={onClick}/> 

            Specify parameters and their types and return type
                type ButtonProps = {
                    onClick: (test: string) => number
                }

        TYPES FOR CHILDREN PROP
            Giving children to component instance
                <Button>Click me</Button>
            
            Consume prop in component
                export default function Button({children}){
                    ...
                }

            Define in the ButtonProps
                type ButonProps = {
                    children: React.ReactNode 
                }

            FROM REACT
                React.ReactNode
                React.CSSProperties
                React.ReactElement
                React.Dispatch<React.SetStateAction<number>>
                React.MouseEvent<HTMLButtonElement, MouseEvent>
                <HTMLButtonElement>
                REACT.JSX.ELEMENT

            REACT.REACTNODE
                Allows for a range of types that can be rendered by React.
                    string: text content
                    number: numberic contenxt
                    boolean: true or false
                    null: nothing
                    undefined: no content
                    ReactElement: jsx
                    ReactFragment: fragment containing multiple children
                    ReactPortal: portal that renders childen into different parts of the dom
                
        TYPE FOR SET STATE FUNCTION 
            Giving SET FUNCTION to component instance
                <Button setCount={setCount}>Click me</Button>
            
            Consume prop in component
                export default function Button({setCount}){
                    ...
                }

            Define in the ButtonProps
                type ButonProps = {
                    setCount: React.Dispatch<React.SetStateAction<number>>
                }

            React.Dispatch<React.SetStateAction<number>>
                Type of a state setter function returned by useState hook in react.
                Ensures that the setter function can accept either a new state value directly or a function that takes the previous state and returns a new value.

                React.Dispatch
                    dispatch function hat can be used to update state
                React.SetStateAction<number>
                    action that can be dispatched, either new state value number or function with prev state returning new type of number.
            
        ComponentProps<"element"> 
            This line means that ButtonProps will inherit all the props of a native HTML <button> element.

            ComponentProps: 
                This utility type extracts the props of a given React component or an HTML intrinsic element (like "button", "div", etc.).

            <"button">: 
                This specifies which component or HTML element you want to extract props from. In this case, it's the intrinsic "button" element.

            HOW
                HTML elements in React, such as <button>, have predefined props, like onClick, disabled, and so on.
                ComponentProps<"button"> automatically generates the type definition for these props, so you don't need to manually define them. 
                
            EXAMPLE
                type ButtonProps = ComponentProps<'button'>

                ONLY SPEAD(...PROPS)
                    const Button: React.FC<ButtonProps> = (props) => {
                        return <button {...props}>{props.children}</button>    
                    }

                REST OP(...REST)
                const Button: React.FC<ButtonProps> = ({type, autoFocus, ...rest}) => {
                    return <button type={type}, autoFocus={autoFocus}, {...rest}>{props.children}</button>    
                }
                
                <Button type="submit" autoFocus={true} defaultValue="test"/>

            HELPER(UTILITY) TYPES
                Predefined types that simplify common type manipulation.
                
                Syntax for Helper Types:
                    Helper types typically use generics. For example:
                        type MyType<T> = Partial<T>;

                COMMONLY USED 
                    Partial<T>: Makes all properties of a type optional.
                        type Person = { name: string; age: number };
                        type OptionalPerson = Partial<Person>;
                        // { name?: string; age?: number }
                    Required<T>: Makes all properties of a type required.
                        type OptionalPerson = { name?: string; age?: number };
                        type FullPerson = Required<OptionalPerson>;
                        // { name: string; age: number }
                    Readonly<T>: Makes all properties read-only.
                        type Person = { name: string; age: number };
                        type ReadonlyPerson = Readonly<Person>;
                        // { readonly name: string; readonly age: number }
                    Pick<T, K>: Picks specific keys from a type.
                        type Person = { name: string; age: number; location: string };
                        type NameAndAge = Pick<Person, "name" | "age">;
                        // { name: string; age: number }
                    Omit<T, K>: Excludes specific keys from a type.
                        type Person = { name: string; age: number; location: string };
                        type WithoutLocation = Omit<Person, "location">;
                        // { name: string; age: number }
                    Record<K, T>: Creates a type with keys K and values of type T.
                        type RolePermissions = Record<"admin" | "editor" | "viewer", boolean>;
                        // { admin: boolean; editor: boolean; viewer: boolean }
                
        INTERSECTION 
            Way to combine multiple types into a single type including all properties and methods of each constituent type. (&)

            EXAMPLE
                Situation to determine the props for a regular element and then inrtersect with something extra for another element.

                type = ButtonProps = {
                    type: "button" | "submit" | "reset",
                    color: "red" | "blue" | "green"
                }
                type SuperButtonProps = ButtonProps & {
                    size: "md" | "lg"
                }

            EXAMPLE FOR INTERFACE
                type SuperButtonProps extends ButtonProps {
                    size: "md" | "lg"
                }

    IN EVENT HANDLERS
        INLINE
            Ts can infer the type of the parameters of inline handlers.

            EXAMPLE
            <button onClick = (e) => console.log("clicked")> 
            TYPE: event: React.MouseEvent<HTMLButtonElement, MouseEvent>

        EXTRACTED
            No longer infered, must define manual.

            const handleClick = (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => console.log("clicked")

    WITH STATE
        Ts can infer the type with the default value. 
        Manual definition of type can also be done.

        EXAMPLE
            useState<number>(3)

        WITH NULL INITIATION
            1)Make sure the type is defined and unioned with null
                type User = {
                    name:string
                }
                const [user, setUser] = useState<User | null>(null)
            
            2)Guard clause for when the state is actually null
                const name = user?.name

    WITH USEREF
        const ref = useRef<HTMLButtonElement>(null)
    
    AS CONST
        Makes an inferred type a literal typ
        Makes the type a readonly

    ASSERT
        Explicitly giving a type to something ts has inferred.

        type ButtonColor = "red" | "blue" | "green"

        useEffect(() => {
            const previousButtonColor = localStorage.getItem("buttonColor") as ButtonColor
        }, [])

    GENERICS
        With react, must have a comma after defining the generic type. 
            <T,> this is so ts does not confuse this with an html element

        INLINE
            function ConvertToArray <T> (contValue: T): T[] {  
                ...              
                }
        EXTRACTED
            type ButtonProps<T> = {
                countValue:T,
                countHistory: T[]    
            }
            export default function Button<T>({countValue, countHistory}: ButtonProps<T>)

    EXPORT AND IMPORT
        EXPORT
            LIB folder  
                types.ts 
                    export type Color = "red" | "green" | "blue"

        IMPORT 
            import {type Color} from "@/lib/types"
            

    UNKNOWN
        Some situations where data is unknown, ts will default to any(e.g. Fetching from an API)

        .then((response) => response.json())
        .then((data:unknown) => console.log(data))

        ZOD
            Following the example above, we can parse the data through zod to ensure it will be the particular form we thought it would be. 
            
    IN COMPONENT RETURN TYPE
        Ts can infer the return type of a react element.
            REACT.JSX.ELEMENT | JSX.ELEMENT 

    WHERE TO REACT TYPES COME FROM 
        React.ReactNode
        React.CSSProperties

        Nodemodules and that gets them from the repo definitely typed

    TSCONFIG.JSON
        
        
    ZOD
        Validator of types and parser

    TS-RESET
        
    
PROJECT 4 - CORPCOMMENT
    WHAT
        write comment about something 
        # to categorize the comment
        # of characters limit
        filter by #
        Upvoting
        Persisting data to server
        get - post data 

    TOOLS
        TS
        CONTEXT
        ZUSTAND

    VITE WITH TS FRESH LOOKAROUND
        npm create vite@4.4.1 . 

    .d.ts files
        Declaration files that make declarations available

    RADIX ICONS
        npm install @radix-ui/react-icons@1.3.0

    TS in state
        Infers based on the initialValue

        INFERED TYPE NEVER BASED ON EMPTY INITIAL STATE
            Type 'TFeedbackItem' is not assignable to type 'never'.ts(2322)

            PROBLEM
                const [feedbackItems, setFeedbackItems] = useState([]);

            ANSWER
                const [feedbackItems, setFeedbackItems] = useState<TFeedbackItem[]>([]);

                

    TS IN e param of handler function
        EXTRACTED
            e: React.ChangeEvent<HTMLTextAreaElement>

        INLINE
            <textarea onChange((e) => ...)>...</textarea> -> ts can recognize it is a change event on a text area element.

    EXPLICIT RETURN ON MAP
        blabla.map((item) => ({ ->allows to return object or component without writing the word
        }))

    TS IN PROPS
        Takes care of you
            intellisense
            no grammar mistakes
        
    LOADINGSTATE
        isLoading state
        conditionally render spinner

    Ts in data methods
        Depending on the data type method, ts could return undefined. In this cases we need to narrow it down and add guard clasuses so ts knows the undefined case has been handled. 

    OPTIMISITC POSTING AND RENDER
        update ui first
        post data to server second

    COMPONENT STRUCTURE
        create folders to improve the folder structure of the app 
            src
                app.tsx
                layout  
                    header.tsx
                    container.tsx
                    footer.tsx
                feedback
                    all items related to this
                ...rest
    
    indexOf() method
        find position of first ocurrence of specific value in an array. 
        
        SYNTAX
            array.indexOf(element, start[opt])

        RETURN
            index of first ocurrence
            -1 if not found

        EXAMPLE
            How to remove duplicate items from the company list array 
              const companyList = feedbackItems
                .map((item) => item.company)
                .filter((company, index, array) => array.indexOf(company) === index); //more derived state

    HASHTAG FEATURE
        hashtag list
            hastag item
                company name from feedback items
                removed duplicate
                inserted hasthtag
        filter by hashtag item
            create selectedCompany state
            add condition to filter feedbacklist items based on this state
            setSelectedFilter function on an onClick button event of the hashtag list items 
                create function and pass it down from app -> #list -> #item 

    ? OP WITH FILTERING A STATE
        selectedFilter state ? filter the list : original list 

    USEMEMO(memory efficient hook)
        Avoid computation by storing calculations in memory
    
        usual dependencies(states used inside determine the dependencies) 
            1)state worked on
            2)state that can change item 1

    Toggle feedback item
        state to control toggle
        conditionally style based on state
        change state with event handler

    Upvote feature
        upvotelocalstate and setstate(initialize with upvote )
        onClick event handler -> setstate
        e.stopPropagation()
        limit upvote
            
    validation when user submits form 
        conditionally render styles on form depending on both states
            green - correct format (conditions for valid)
                state for valid
                setstate true
                setTimeout - to turn off state
            
            red - incorrect format
                state for invalid
                setstate true
                setTimeout - to turn off state
                return - we don't want the rest of code to execute

    CUSTOM HOOK FOR CONTEXT
        1)encapsulates the validation logic 
        2)allows the validation logic to be reused
        3)once we get context, we avoid initial null value scenario 

    DOWNFALL OF CONTEXT
        If even 1 thing in the values object changes, the whole lot of components will have to re render. 
        
    CREATION OF CUSTOM HOOK FOR DATA FETCHING
         
    
P5 - RMTDEV
--------------

TO LEARN(NEW TOPICS)
    1)React Query 
    2)Cache
    3)Debounce

FEATURES(SECTIONS)
    1)Search jobs
    2)Job List
    3)Job Details
    4)Pagination
    5)Sorting
    6)Bookmarks

INITIALIZE PROJECT
    CLONE REPO  
        git clone https://github.com/ByteGrad/starter-rmtdev.git .

        NO .
            Creates folder with repo name.

        WITH .
            Unloads the files of the repo in the folder we are located in the terminal.

1.1)SEARCH
    Search Component(Controlled Input)
        OnSubmit Handler
            Create handleSubmit function
            e.preventDefault
            e: React.FormEvent<HtmlFormElement>
        searchText state
            const [searchText, setSearchText] = useState<string>("")
        onChange function
            e: React.ChangeEvent<HtmlInputElement>
            setSearchText(e.target.value)
        Input Element
            value={searchText}
    Fetch jobItems on search
        REQUIREMENT
            Should fetch every time the input detects a change, NOT depending if state changes
        WHERE
            useEffect
                Guard Clause
                    !searchText return -> avoid fetching on an empty state in the initial render
                Dependency
                    searchText -> Fetches on the re render caused by the state change with the most recent value
        ANATOMY
            fetchJobItems async function
                !res.ok
                    Throw Error
              setJobItems state to data.jobItems from fetch
1.2)Showing jobItems(search results)
        List state up
            Move searchText & jobItems to App
        Render jobItems
            Prop Drill
                App -> Container -> Sidebar -> jobLst
            jobList
                map jobList and return a <jobListItem/> for every item
            jobListItem
                render jobItem info
    Typing 
        jobItem and jobListItem
    Prevent Prop Drilling
        Children Pattern
            Typing all components using children
                children: React.ReactNode
    Loading 
        State
            const [isLoading, setIsLoading] = useState(false)
        WHERE 
            Before fetch
                true
            After success fetch
                false
        CONDITIONALLY RENDER SPINNER
            {isLoading && <Spinner/>}    -> Only shows spinner if it is loading
            {!isLoading && jobItems.map  -> Only shows ListItems if fetch is no longer fetching
    Type
        JobItem
            exported to types file
        JobList
            Jobitems: JobItem []
            isLoading: boolean
        JobListItem
            jobItem: JobItem
    useJobItems custom Hook
        Objective
            Group all logic related to this feature in a single place
        Benefit
            1)De clutter main app or files unnecessary for this
            2)If implementation wants to be changed, only 1 place to work on
                useEffect
                React-Query
                Other libraries
            3)Re use logic
    Slice jobItems into a Page
        jobItems.slice(0,7)

        WHERE
            useJobItems custom hook
    JobItems to Tuple
        WHY
            Where prop is sent
                Receives type as union number | string
            Where prop is used
                Props is defined as what it should be ideally
        PROB
            Both come into conflict and must be addressed
        SOLU
            Tuple will provide ideal type for each
                return [jobItemsSliced,isLoading] as const
    Key Prop
        Funny enough, it must be given but react won't pass it. 
        It won't be received on the component definition side. 
    Type Form
        searchText: string
        setSearchText: React.Dispatch<React.SetStateFunction<string>>.
2)JOB DETAILS
    Keep track of active job Id
        WHY 
            1)style based on active job
            2)share current id for page to load in that state
        URL HASH
            fulfills requirements to share and load.
            state will lose its value on initial load.

            WRITING
                <a href={`#${jobItem.id}`}
                HOW
                    Window.location.href gets or sets the url.
                    Anchor tags href prop has access to the window.location.href   
            READING
                Tap into hashchange event with an event listener.
                WHERE
                    UseEffect
                HOW
                    window.addEventListener("hashchange", () => {...})
        Initially call to handlehaschange
            if there is something in the hash
            useEffect runs the function without need for hashchange event

            PRO
                Avoids need to set initial value | null in state


        STATE
            const [activeId, setActiveId] = useState<number | null>(null) 
            WHERE
                app, b/c jobList and jobItemContent need it
            WHY
                Hash alone won't cause re renders, it is for data persistance only.
            
    useActiveId custom Hook
        Objective
            Group all logic related to this feature in a single place
        Benefit
            1)De clutter main app or files unnecessary for this
            2)If implementation wants to be changed, only 1 place to work on
    Fetch jobItemContent(Custom Hook)
        WHEN 
            activeId changes
        REMEMBER
            onClick for specific jobItem already deals with changing the hash and the activeId state. We can work with reacting to this change. 
        guardClause
            !activeId return
        Types consistency is enforced
            A type defined before (activeID = number | null) will force you to keep that same type and work around it.

            EXAMPLE
                useJobItemContent(activeId: number | null)
                    type narrow the null case with guard clasue
                    only number type is left to deal with
    type JobItemContent
        perfect example of type intersection
            export type JobItemContent = JobItem & {
            ... extra
        }
        Initial type for JobItemContet useState
            JobItemContent | null
            WHY
                When initialized, there is a scenario in which the fetch is not run b/c activId is not there and has not changed. 
                    In this situation we work with null.

            Guard clause
                Rememember to always guard clause a null state
            Prop does not exist on type never Error
                Error message when state is initialized empty and is not unioned with the actual type
        Importing same name type as component
            import {type JobItemContent}
    Render JobItemContent
        Render EmptyJobContent
            if !JobItemContent return <EmptyJobContent/>
    isLoading
        Multiple isLoading must be in separate files. 
    Style active jobListItem
        inside jobListItem
            useActiveId c-hook
            isActive={activdeId == jobItem.id} -> conditionally render prop to produce boolean value
    ResultsCount
        derived state in useJobItems hook where info is readily available
3)Debounce searchText
    Obj
        Limit api fetch until user has finished typing in input
    HOW
        Fetch with a debounced searchText
    
    STEPS
        useEffect(() => {
            const timerId = setTimeout(() => setDebouncedSearchText(searchText), 1000)
            return () => clearTimeout(timerId)
        },[searchText])
    type with generics
        useDebounce<T>(value:T,delay = 1000):T
    Default params
        Perfect use for a standard delay unless user specifies.
4)Changing fetch to React-Query
    Obj
       Store recently fetched data to avoid re fetching
    WHERE
        1)jobItems
        2)jobItemContent
    PROVIDER
        Establish a provider in the main file with <App>
    
    
    
    
----------------

React Query
    Powerful library to manage state and fetching.

    WHY
        Automaically handles all the manual things you are used to doing:
            1)loading 
            2)errors
            3)caching
            4)refetching stale info
    COMPARISON
        WITHOUT
            useEffect -> fetch
            useState -> result
            useState -> loading
            useState -> errors
            manual re fetch for stale info
        WITH
            useQuery hook
    INSTALL
        npm install @tanstack/react-query
    SETUP QUERY CLIENT IN MAIN FILE
        import {QueryClient, QueryClientProvider} from "@tanstack/react-query"

        const queryClient = new QueryClient()

        function App() {
            return(
                <QueryClientProvider client={QueryClient}>
                    <...>
                </QueryClientProvider>
            )
        }
    
        WHAT HAPPENS
            Query client wraps around your app and enables caching for all app.
    FETCH DATA WITH USEQUERY
        import {useQuery} from "@tanstack/react-query"

        function MyComponent() {
            const {data,error,isLoading} = useQuery({
                queryKey: ['key'], 
                queryFn: async () => {
                    const response = await fetch("https://your-api.com/data");
                    if (!response.ok) {
                    throw new Error("Network response was not ok");
                }   
                    return response.json(); // Return the parsed JSON data
                },
                staleTime: 1000 * 60 * 5, 
                cacheTime: 1000 * 60 * 10,
                refetchOnWindowFocus: false, // 
            })
        }
        PARAMS
            queryKey                -> unique key to remember query for caching
            queryFn                 -> fn that fetches
            isLoading               -> true while fetching
            error                   -> request fails(500)
            data ->                 -> data response
            staleTime               -> (Optional) Keep data fresh
            cacheTime               -> (Optional) Keep data in cache
            refetchOnWindowFocus    -> (Optional) Prevent refetching when window regains focus
            enabled                 -> (optional) Run on mount? (boolean)
        RETURNED
            Property	Type	        Description
            data	    Object / Array	The response data from the API.
            error	    Object / null	The error object if the request fails.
            isLoading	Boolean	        true while the query is fetching for the first time.
            isError	    Boolean	        true if an error occurred.
            isFetching	Boolean	        true if React Query is refetching data in the background.
            refetch	    Function	    A function to manually trigger a refetch.
    IMPROVEMENTS
        1)No more manual state handling(isLoading, Error, Data)
        2)Cache
        3)auto updates stale data
        4)No need for custom try catch
        

LEARNED - SUMMARY
    cacheing
        storing frequently accessed data in a temp storage location to reduce retrieval time and improve performance. 
        POPULAR WAYS
            1)react-query
            2)nextjs
            3)swr vercel
    clone repo to here
        git clone https://github.com/ByteGrad/starter-rmtdev.git .
    sharing repo    
        package.json to install node_modules and avoid uploading the massive folder 
    icon to use action
        wrap icon in a button 
            example
                BookmarkIcon
                BookmarkButton
    reusability even in small components
        BookmarkIcon component 
    logo to start page
        wrap image or icon in anchor tag 
    FETCHING BASED ON PURPOSE
        onLoad
            useEffect
                state as dependency
                    state changes:
                        1)component re renders
                        2)state is given as input value
                        3)useEffect runs again and fetches based on most recent state value
        onReaction
            onChange(equivalent event)
    Params
        Query
            resource located, need to filter further
            example
                search
                sortBy
                limit
        Path(Route)
            locate specific resoure
    Never Type
        Ts type that represents a value that never occurs. 
        Expression will never produce a value.
        Ts will infer this value when initializing an empty array [].
    Loading state
        isLoading && <Spinner/>
            Always needed
        !isLoading && Data.map
            Prevents niche cases of previous fetch data existing and new fetch being loaded
    How custom hooks work
        HOW
            By following proper hook logic, we guarantee it will work as if it is not there
        Objective
            Group all logic related to this feature in a single place
        Benefit
            1)De clutter main app or files unnecessary for this
            2)If implementation wants to be changed, only 1 place to work on
                useEffect
                React-Query
                Other libraries
            3)Re use logic
    Returning array from custom hook
        SITUATION
            Where prop is sent
                Receives type as union number | string
            Where prop is used
                Props is defined as what it should be ideally
        PROB
            Both come into conflict and must be addressed
        SOLU
            Tuple will provide ideal type for each
                return [jobItemsSliced,isLoading] as const
    Key Prop
        Funny enough, it must be given but react won't pass it. 
        It won't be received on the component definition side. 
    Window object
        Global namespace with global variables and functions as properties.
        
        1)size and position
        2)document and DOM access
            .document  -> html DOM
            .location  -> current URL(protocol, hosty)
                1).href      -> get or set URL  
                2).reload()  -> reload page
                3).assign()  -> navigate to new URL
                4).replace() -> replaces in url in history, no back option  
            .history   -> browser session history
            .navigator -> browser and device info
    Window.location.hash
        Fragment identifier in a URL, part after the #.
        Write
            window.location.has = "jobId"
        Read
            const id=window.location.hash.substring(1)
        Reacting to hash change
            window.addEventListener("hashchange", () => {...})
    Returning function in useEffect
        Remember to clean up after side effects
    Types consistency is enforced
        A type  defined before (activeID = number | null) will force you to keep that same type and work around it. (useJobIems(activeID))
    Excellent useCase for Type Intersection
        Types where you fetch surface info on list
        And then fetch details for the details page
    Importing same name type as component
        import {type JobItemContent}
    State<type | null> and Type Narrow
        Always make sure you contemplate the null case of the state first
        When you look for something inside state, if null is not dealed with first, it will give error.
    isLoading
        Multiple isLoading must be in separate files.        
    Order of logic / conditional 
        Negatvie cases first
            isLoading?
            !var
            positive return for component
    Debounce searchText
        Technique to limit # of times a function is executed.
        Ensures function is only executed after a specific delay.
        HOW
            1)each time event is triggered, timer is set.
            2)if event is triggered before timer ends, time restarts.
            3)func executes only after timer has finished wihtout interruptions.
        WHEN
            1)search input
            2)button click prevention
            3)windowx resize
    C-hooks library
        usehooks-ts.com
    Tip when determining where to locate hooks or functions
        Look at where you already have access to data

        EXAMPLE
            debouncesearchtext can be in app b/c searchtext is already there.
    SetTimeout in Reac
        Accumulated timeouts will execute.

        SOLUTION
            Removal of each of the unnecessary calls. 
            1)store id of each
            2)return a function that executes clearTimeout with that id.
---------
    Sending complex info as prop
        If it is a list, and you are rendering a component, send the entire object as an item and destructure on the other side. 
    Typing API Resp
        analyze what comes back and type the object of the response
    Children prop to encapsulate html tags
        create component that will use a div to wrap around children. This encapsulates logic. 
    
    
        
        
            


    
                


    
    
    
            

        



                    




        



        





        


-->
