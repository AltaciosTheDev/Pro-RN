<!-- 
CONCEPT RECAP
    1)jsx
    2)fragments
    3)components
    4)props
    5)event handlers
    6)hooks
    7)shortcuts (rfc)
    8)useState - renders 
    9)useEffect - side effects 
    10)() return several lines
    11)`` ${} template literals
    12)return -> exit from function 
    13)... -> spred operator
    14)&& short circuiting 
    15)style={{fontStyle="50px"}}
    16)every component could import its own css file 
    17)let,var,const
    18)controlled input

SIMPLE LOGGIC BEHIND LOADING A WEB PAGE
    1)client requests url to server
    2)server serves the index.html
    3)index.html links to all the static files(fonts, images, stylesheets,favicon)
    4)client will make network request for all those static files

NEW KNOWLEDGE
    1)arrow funcs need to be exported at the end of the file
    2)"react/prop-types":"off"

PROJECT 1 - FANCY COUNTER
    CREATE PROJECT WITH VITE
        npm create vite@version
        npm install
        npm run dev

    PAKCHAGE JSON
        All important information about the project(versions, commands, dependencies)

    ESLINT
        Can install extension but config file will take precedence.

    HOW CAN PEOPLE GET NODE_MODULES
        npm install
            installs dependencies on the package.json
        .gitignore
            holds the node_modules so they are not commited or shared

    WHERE TO STORE IMAGES
        src
            assets
                if they are referenced
        public
            if they are not referenced

    AUTO IMPORTS
        ctrl+enter -> should pop up intellisense

PROEJECT 2 - WORD ANALYTICS
    TO LEARN
        Character analyzer to see how many characters are left in a post for social media.
    
    CREATE PROJECT
        npm create vite@version . 

    TRIIGGER INTELLISENSE
        ctrl + space
        enter

    REMEMBER SEMANTIC HTML
        <header>
        <footer>
        <main>
        <section>

    REMEMBER RETURN
        return from negative paths to prevent rest of code to execute
        
    DON'T NEED TO ADD MORE STATE
        Analyze if states are very closely related and eliminate one. 
        Boolean state is not necessary, we can condition with trushy and falsy states.
    
    DERIVED STATE
        Calculations based on an existing state.
        Avoids overpopulating with more states.

    LIFTING STATE UP 
        To parent component that can distribute to all children in need.

    PASSING PROPS AS DESTRUCTURED OBJECT
        Passing a lot of props gets messy and tedious.

        const stats = {
            numberOfWords: text.split(/\s/).filter((word) => word !== "").length,
            numberOfCharacters: text.length,
            instagramCharactersLeft: 280 - text.length,
            facebookCharactersLeft: 2200 - text.length,
        };

        <Stats
            {...stats}
        />

    CONDITIONAL STYLING IN REACT
        className={`original clases ${var ? "classToRender" : ""}`}

    EXTRACTING CONSTANTS IN SEPARATE FILE
        Every single constant value, in separate constants.js file.
        
        EXAMPLE
            export const INSTAGRAM_MAX_CHARACTERS = 280
            export const FACEBOOK_MAX_CHARACTERS = 280
    
    FOLDER STRUCTURE
        paths must be relative to the main.jsx

        COMPONENTS
            all react components
        LIB
            constants
            hooks
            utilites

INTERMEDIATE REACT & JAVASCRIPT
    ARRAYS - INTERMEDIATE
        push
        length
        .forEach
        item[#]
    OBJECTS - INTERMEDIATE
        nested objects
        property shorthands
    ARRAYS - ADVANCED
        .push()
        .map() - returns new array - always specify return keyword
        .some() - returns true if at least 1 element fulfills condition - always specify return keyword
        .find() - returns 1st element or undefined - always specify return keyword
        .filter() - returns new array with elements that specify condition - always specify return keyword
    
    OBJECTS - ADVANCED
        bracker notation 
            object[property]
    SPREAD OPERATOR
        const totalArry = [...arr, ...arr2]
    DESTRUCTURING
        const {name} = user -> must be same name
        const [anything] = cart -> order is what matters
    PRIMITIVES VS REFERENCES
        only primitives can be compared(== || ===)
        reference -> you get pointers to where the data is stored -> thats why they can't be compared
    SHORT CIRCUITING && --
        && -> super consice if this is true, run the right part.
        || -> if first is true, stop there. If first is false, run second.
    FUNCTIONS - INTERMEDIATE
        order of execution 
        refactoring -> get rid of redundant code always
        early return -> stops function execution
    FUNCTIONS - ADVANCED
        callbacks -> function as parameter
        method -> function on something
            this keyword only works on traditional function (not arrows)
        default param
            could avoid undefinde in a math operation
    FETCH - INTRO
        words we can type without error are browser included:
            fetch()
        json -> syntad used by client - server communication 
            readable
            supported by most prog-langs
        .then()
            handles a promise -> must return 
        .catch()
            handles errors from the server
        if(!res.ok) -> method that comes with fetch promise -> indicates if response status is in the 200s. This is necessary b/c .catch won;t always catch all errors.
        
    ASYNC - AWAIT
        More modern syntax

        try{
            res = await fetch 
            data = await res
        }
        catch{
            errror
        }

    CUSTOM HOOKS
        Functions that incorporate default hooks + additional logic

        WHERE TO PUT
            hooks folder
                specific hook file

    RULES OF HOOKS
        NOT IN 
            loops
            conditions
            nested functions
            after early return statement

PROJECT 3 - TREKBAG 
    FEATURES
        add items in form (done)
        delete items (done)
        check items (done )
        sort
            pack
            unpacked
            default 
        reset to initial (done)
        mark all as complete(done)
        mark all as incomplete(done)
        remove all items(done)
        localstorage for data persistence
        counter

    TO LEARN
        context api
        zustand
    
    ESLINT
        Pop linting tool for js and ts. 
        Finds potential bugs by analyzing files and flagging issues based on predefined or custom rules.

    ESLINT-PLUGIN-REACT
        specifically for react.
        same as normal eslint but related to react and jsx.
    ESLINT-PLUGIN-REACT-HOOKS
        enforces rules of react hooks.
        ensures popular hooks are used correctly following react guidelines.

    LOOP
        ALWAYS loop when you are repeating your code.
    
    STATIC DATA
        If in file, store outside component definition

    EMOJI POP UP MODAL
        windows + . 
    
    NEW DATE().GETTIME()
        Can be used as a substitute for an id in an object in a database

    useRef()
        Hook to literally hook in a ref for an element in the browser.
        useEffect()

    TOAST instead of ALERTS
        more professional

    IMPLEMENTATION LOGIC AND STATE IN 1 PLACE
        Standard practice to keep in 1 place:
            state
            derived state
                normal arithmetic logic on existing state
            logic handlers

    onEvent - onHandleEvent
        When the prop reaches the component that will make use of it,change naming to onEvent to keep html standards.

    SORTING
        1)place component
            React-Select Library
                Represents a whole new approach to developing powerful React.js components that just work out of the box, while being extremely customisable.
        2)Set props
            onChange
            options
            setDefaultValue
        3)make UI change depending on the sortState
            create sort state
            sort array
            map sorted array 
    
    LOCALSTORAGE
        Store items
        UseEffect
        initialize state with return from lc || initial data if lc empty

    USEMEMO
        hook in react to avoid doing recalculation by storing a computation in memory until dependencies change. 
        SYNTAX
            Same useEffefcct syntax
        WHY
            Avoid recalculating taxing stuff on every re render, only when deps change.
        SIMILAR TO
            not wanting to run useeffect on every re render b/c of performance


    CHILDREN COMPOSITION
        Pretty much just move the components higher and bloat up higher to avoid prop drilling.

    CONTEXT
        Hook that allows for the transport of information. 

        1)CREATE CONTEXT COMPONENT
            <ItemsContextProvider>
            1.1)Outside that component definition createContext
                const ItemsContext = createContext()

            1.2)return the context.provider
                return(
                    <ItemsContext.Provider value={{objWithData}}>{children}</ItemsContext.Provider>
                )
        2)WRAP ELEMENTS WITH CONTEXT
            <ItemsContextProvider>
                <everything else>
            </ItemsContextProvider>
        3)export and consume the context from somewhere
            1)export it from the file where it was created
                export ItemsContext = createContext()
            2)consume it
                const {this,that} = useContext(ItemsContext)

        PROBLEMS
            No selectors, meaning every component attached to a part of context will always render if 1 of them change. 
            Big apps will need A LOT of context providers. That will mean a lot of boilerplate code and wrapping of components. 
            Middleware and advanced, context is limited. 
            

    CUSTOM HOOKS
        Regular js function that encompasses and makes use of a hook.

        STRUCTURE
            lib
                hook.js

        EXAMPLE
            export function useItemsContext() {
                const context = useContext(ItemsContext)

                if(!context) {
                    throw new Error
                }
                return context
            }
        BENEFITS
            1 import instead of 2(useContext, itemsContext)
            easier to write useItemsContext() instead of useContext(ItemsContext)
            when using typescript will have to account for situation in which context returns nothing.This logic can be handled here
        
        
    ZUSTAND 
        State management library for react providing simple, lightweight, flexible alternative to redux. 

        BENEFITS
            ease of use
            minimal boilerplate
            powerful capabilities

        WHY IT WORKS WELL
            simplicity
                intuitive and no strict pattern
            performance 
                no unnecessary re-renders
            no context provider hell
                no context api use, so no context provider hell
            versatility
                supports both local and global state management, suitable for different scale applications
            merging of state
                dont have to spread the store object, only the modified part will be changed.
                No need to specify {...store, propToChange: newValue}

        INSTALL 
            npm install zustand

        WHERE
            stores(folder)
                itemsStore.js/ts

        HOW
            Creates a store for managing state. 

            1)store creation
                create function to define state and actions.  

                import create from 'zustand'
            
                const useStore = create((set) => {
                    bears:0,
                    increasePopulation: () => set((state) => ({bears: state.bears + 1})) -> previous State needed, set receives it as parameter
                    removeAllBears: () => set({bears: 0})                                -> no prev state needed, just replace the state.
                    updateBears: (newBears) => set({bears: newBears})                    -> payload from outside needed. Main function receives as param. 
                })
            *)export store
                const export useItemStore = create((set) => ({store}))

            2)accessing the store 
                inside component
                    const bears = useStore((state) => state.bears)
                    const increasePopulation = useStore((state) => state.increasePopulation)

            3)state update
                zustand uses "set" function to update state. 
                Reactive updates: only parts using the affected parts will re render.
            4)middleware support
                supports middleware like extending state or logging changes.
            
        ADVANCED FEATURES
            1)selectors
                derived state
                pick specific parts of the store
            2)middleware
                you can enhance the store with middleware for logging, persistance or async actions.

        WHEN
            small - medium sized applications
            simple alternative to redux
            global state managemnt NO boilerplate
            avoiding limits of context API

        WHERE ZUSTAND SHINES
            NO PROVIDER COMPONENT HELL
            NO UNNECESARY RE RENDER
            NO NEED TO SPREAD STATE, MORE DECLARATIVE PROGRAMMING
            SIMPLE TO SET AND USE
            SMALL,MID,LARGE PROJECTS 
            AVANCED MIDDLEWARE like persist for localstorage
            
TYPESCRIPT IN REACT
    IN COMPONENT PROPS:
        MAINTAINS CONSISTENCY IN PROPS GIVEN AND NEEDED
            Instance
                Given props not defined in component definition will return error.
                    Property 'pillshape' does not exist on type 'IntrinsicAttributes & ButtonProps'
                Missing props defined but not given will remind the user they are needed.
                   Type '{}' is missing the following properties from type 'ButtonProps': backgroundColor, fontSize, pillShapets(2739)

            Definition
                Defined props not used, will return error.
                    'backgroundColor' is defined but never used
            
            INTELLISENSE
                ctrl+space
                    Ts will show all the possible props that the component is expecting

        DEFINING PROP TYPES
            Since prop is an object, prop types will be for objects.

            SYNTAX 1 - INLINE
                export default function Button({backgroundColor,fontSize pillShape}:{backgroundColor:string, fontSize:number, pillShape: boolean}) {
                    return (
                        <button>
                            ...
                        </button>
                    );
                }

            SYNTAX 2 - EXTRACTED PROP TYPE
                Declare type outside of component definition

                type ButtonProps = {backgroundColor:string, fontSize:number, pillShape: boolean}

                export default function Button({backgroundColor,fontSize, pillShape}:ButtonProps) {
                    return (
                        <button className="bg-blue-500 text-white rounded px-4 py-2">
                        Click me
                        </button>
                    );
                }

                EXTRACTED UNION TYPE FOR ALREADY EXTRACTED PROP TYPE
                    type Color = "red" | "blue" | "green"
                    type ButtonProps = {backgroundColor: Color, fontSize:number, pillShape: boolean}


        OPTIONAL PROP 
            type ButtonProps = {backgroundColor:string, fontSize:number, pillShape?: boolean}

        ARRAY TYPE FOR PROP
            type ButtonProps = {backgroundColor: Color[], fontSize:number, pillShape: boolean, padding: number[]}

        TUPLE TYPE FOR PROP
            Will determine:
                1)specific number of elements
                2)type of each specific element

            type ButtonProps = {backgroundColor: Color[], fontSize:number, pillShape: boolean, padding: [number, number, number]}
            <Button padding: [44,33,22]/> -> only 3 elements b/c that is what is defined in the tuple 

        USING AND OBJECT FOR STYLE INSTEAD OF INDIVIDUAL PROPERTIES
            MANUAL 
                type ButtonProps = {
                    style: {
                        backgroundColor: string,
                        fontSize: number
                        etc
                    }
                }

                <Button style={{backgroundColor: "blue", fontSize: 24}}/>
            
            REACT CSS PROPERTIES TYPE
                type ButtonProps = {
                    style: React.CSSProperties
                }

                WHY?
                    Permits use to pass an object filled with actual css properties in the component instance AND AVOID writing all of them in the type created, b/c this is already done by React.
                    Will tell you if you wrote incorrectly a property in the instance, since it will not exist in the interface created by react
                    Will tell you if the value you wrote is incorrect, since it is already defined in he interface what values are permited.

        GENERICS IN PROP TYPES
            type ButtonProps = {
                borderRadius: Record<string, number>
            }

            <Button borderRadius={{
                topLeft: 5,
                topRight: 5, 
                bottomRight:10,
                bottomLeft:10
            }}/>

        TYPES FOR FUNCTION PROPS
            Create and pass the function
                const onClick = (test:string) => 5
                <Button onClick={onClick}/> 

            Specify parameters and their types and return type
                type ButtonProps = {
                    onClick: (test: string) => number
                }

        TYPES FOR CHILDREN PROP
            Giving children to component instance
                <Button>Click me</Button>
            
            Consume prop in component
                export default function Button({children}){
                    ...
                }

            Define in the ButtonProps
                type ButonProps = {
                    children: React.ReactNode 
                }

            FROM REACT
                React.ReactNode
                React.CSSProperties
                React.ReactElement
                React.Dispatch<React.SetStateAction<number>>
                React.MouseEvent<HTMLButtonElement, MouseEvent>
                <HTMLButtonElement>
                REACT.JSX.ELEMENT

            REACT.REACTNODE
                Allows for a range of types that can be rendered by React.
                    string: text content
                    number: numberic contenxt
                    boolean: true or false
                    null: nothing
                    undefined: no content
                    ReactElement: jsx
                    ReactFragment: fragment containing multiple children
                    ReactPortal: portal that renders childen into different parts of the dom
                
        TYPE FOR SET STATE FUNCTION 
            Giving SET FUNCTION to component instance
                <Button setCount={setCount}>Click me</Button>
            
            Consume prop in component
                export default function Button({setCount}){
                    ...
                }

            Define in the ButtonProps
                type ButonProps = {
                    setCount: React.Dispatch<React.SetStateAction<number>>
                }

            React.Dispatch<React.SetStateAction<number>>
                Type of a state setter function returned by useState hook in react.
                Ensures that the setter function can accept either a new state value directly or a function that takes the previous state and returns a new value.

                React.Dispatch
                    dispatch function hat can be used to update state
                React.SetStateAction<number>
                    action that can be dispatched, either new state value number or function with prev state returning new type of number.
            
        ComponentProps<"element"> 
            This line means that ButtonProps will inherit all the props of a native HTML <button> element.

            ComponentProps: 
                This utility type extracts the props of a given React component or an HTML intrinsic element (like "button", "div", etc.).

            <"button">: 
                This specifies which component or HTML element you want to extract props from. In this case, it's the intrinsic "button" element.

            HOW
                HTML elements in React, such as <button>, have predefined props, like onClick, disabled, and so on.
                ComponentProps<"button"> automatically generates the type definition for these props, so you don't need to manually define them. 
                
            EXAMPLE
                type ButtonProps = ComponentProps<'button'>

                ONLY SPEAD(...PROPS)
                    const Button: React.FC<ButtonProps> = (props) => {
                        return <button {...props}>{props.children}</button>    
                    }

                REST OP(...REST)
                const Button: React.FC<ButtonProps> = ({type, autoFocus, ...rest}) => {
                    return <button type={type}, autoFocus={autoFocus}, {...rest}>{props.children}</button>    
                }
                
                <Button type="submit" autoFocus={true} defaultValue="test"/>

            HELPER(UTILITY) TYPES
                Predefined types that simplify common type manipulation.
                
                Syntax for Helper Types:
                    Helper types typically use generics. For example:
                        type MyType<T> = Partial<T>;

                COMMONLY USED 
                    Partial<T>: Makes all properties of a type optional.
                        type Person = { name: string; age: number };
                        type OptionalPerson = Partial<Person>;
                        // { name?: string; age?: number }
                    Required<T>: Makes all properties of a type required.
                        type OptionalPerson = { name?: string; age?: number };
                        type FullPerson = Required<OptionalPerson>;
                        // { name: string; age: number }
                    Readonly<T>: Makes all properties read-only.
                        type Person = { name: string; age: number };
                        type ReadonlyPerson = Readonly<Person>;
                        // { readonly name: string; readonly age: number }
                    Pick<T, K>: Picks specific keys from a type.
                        type Person = { name: string; age: number; location: string };
                        type NameAndAge = Pick<Person, "name" | "age">;
                        // { name: string; age: number }
                    Omit<T, K>: Excludes specific keys from a type.
                        type Person = { name: string; age: number; location: string };
                        type WithoutLocation = Omit<Person, "location">;
                        // { name: string; age: number }
                    Record<K, T>: Creates a type with keys K and values of type T.
                        type RolePermissions = Record<"admin" | "editor" | "viewer", boolean>;
                        // { admin: boolean; editor: boolean; viewer: boolean }
                
        INTERSECTION 
            Way to combine multiple types into a single type including all properties and methods of each constituent type. (&)

            EXAMPLE
                Situation to determine the props for a regular element and then inrtersect with something extra for another element.

                type = ButtonProps = {
                    type: "button" | "submit" | "reset",
                    color: "red" | "blue" | "green"
                }
                type SuperButtonProps = ButtonProps & {
                    size: "md" | "lg"
                }

            EXAMPLE FOR INTERFACE
                type SuperButtonProps extends ButtonProps {
                    size: "md" | "lg"
                }

    IN EVENT HANDLERS
        INLINE
            Ts can infer the type of the parameters of inline handlers.

            EXAMPLE
            <button onClick = (e) => console.log("clicked")> 
            TYPE: event: React.MouseEvent<HTMLButtonElement, MouseEvent>

        EXTRACTED
            No longer infered, must define manual.

            const handleClick = (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => console.log("clicked")

    WITH STATE
        Ts can infer the type with the default value. 
        Manual definition of type can also be done.

        EXAMPLE
            useState<number>(3)

        WITH NULL INITIATION
            1)Make sure the type is defined and unioned with null
                type User = {
                    name:string
                }
                const [user, setUser] = useState<User | null>(null)
            
            2)Guard clause for when the state is actually null
                const name = user?.name

    WITH USEREF
        const ref = useRef<HTMLButtonElement>(null)
    
    AS CONST
        Makes an inferred type a literal typ
        Makes the type a readonly

    ASSERT
        Explicitly giving a type to something ts has inferred.

        type ButtonColor = "red" | "blue" | "green"

        useEffect(() => {
            const previousButtonColor = localStorage.getItem("buttonColor") as ButtonColor
        }, [])

    GENERICS
        With react, must have a comma after defining the generic type. 
            <T,> this is so ts does not confuse this with an html element

        INLINE
            function ConvertToArray <T> (contValue: T): T[] {  
                ...              
                }
        EXTRACTED
            type ButtonProps<T> = {
                countValue:T,
                countHistory: T[]    
            }
            export default function Button<T>({countValue, countHistory}: ButtonProps<T>)

    EXPORT AND IMPORT
        EXPORT
            LIB folder  
                types.ts 
                    export type Color = "red" | "green" | "blue"

        IMPORT 
            import {type Color} from "@/lib/types"
            

    UNKNOWN
        Some situations where data is unknown, ts will default to any(e.g. Fetching from an API)

        .then((response) => response.json())
        .then((data:unknown) => console.log(data))

        ZOD
            Following the example above, we can parse the data through zod to ensure it will be the particular form we thought it would be. 
            
    IN COMPONENT RETURN TYPE
        Ts can infer the return type of a react element.
            REACT.JSX.ELEMENT | JSX.ELEMENT 

    WHERE TO REACT TYPES COME FROM 
        React.ReactNode
        React.CSSProperties

        Nodemodules and that gets them from the repo definitely typed

    TSCONFIG.JSON
        
        
    ZOD
        Validator of types and parser

    TS-RESET
        
    
PROJECT 4 - CORPCOMMENT
    WHAT
        write comment about something 
        # to categorize the comment
        # of characters limit
        filter by #
        Upvoting
        Persisting data to server
        get - post data 

    TOOLS
        TS
        CONTEXT
        ZUSTAND

    VITE WITH TS FRESH LOOKAROUND
        npm create vite@4.4.1 . 

    .d.ts files
        Declaration files that make declarations available

    RADIX ICONS
        npm install @radix-ui/react-icons@1.3.0

    TS in state
        Infers based on the initialValue

        INFERED TYPE NEVER BASED ON EMPTY INITIAL STATE
            Type 'TFeedbackItem' is not assignable to type 'never'.ts(2322)

            PROBLEM
                const [feedbackItems, setFeedbackItems] = useState([]);

            ANSWER
                const [feedbackItems, setFeedbackItems] = useState<TFeedbackItem[]>([]);

                

    TS IN e param of handler function
        EXTRACTED
            e: React.ChangeEvent<HTMLTextAreaElement>

        INLINE
            <textarea onChange((e) => ...)>...</textarea> -> ts can recognize it is a change event on a text area element.

    EXPLICIT RETURN ON MAP
        blabla.map((item) => ({ ->allows to return object or component without writing the word
        }))

    TS IN PROPS
        Takes care of you
            intellisense
            no grammar mistakes
        
    LOADINGSTATE
        isLoading state
        conditionally render spinner

    Ts in data methods
        Depending on the data type method, ts could return undefined. In this cases we need to narrow it down and add guard clasuses so ts knows the undefined case has been handled. 

    OPTIMISITC POSTING AND RENDER
        update ui first
        post data to server second

    COMPONENT STRUCTURE
        create folders to improve the folder structure of the app 
            src
                app.tsx
                layout  
                    header.tsx
                    container.tsx
                    footer.tsx
                feedback
                    all items related to this
                ...rest
    
    indexOf() method
        find position of first ocurrence of specific value in an array. 
        
        SYNTAX
            array.indexOf(element, start[opt])

        RETURN
            index of first ocurrence
            -1 if not found

        EXAMPLE
            How to remove duplicate items from the company list array 
              const companyList = feedbackItems
                .map((item) => item.company)
                .filter((company, index, array) => array.indexOf(company) === index); //more derived state

    HASHTAG FEATURE
        hashtag list
            hastag item
                company name from feedback items
                removed duplicate
                inserted hasthtag
        filter by hashtag item
            create selectedCompany state
            add condition to filter feedbacklist items based on this state
            setSelectedFilter function on an onClick button event of the hashtag list items 
                create function and pass it down from app -> #list -> #item 

    ? OP WITH FILTERING A STATE
        selectedFilter state ? filter the list : original list 

    USEMEMO(memory efficient hook)
        Avoid computation by storing calculations in memory
    
        usual dependencies(states used inside determine the dependencies) 
            1)state worked on
            2)state that can change item 1

    Toggle feedback item
        state to control toggle
        conditionally style based on state
        change state with event handler

    Upvote feature
        upvotelocalstate and setstate(initialize with upvote )
        onClick event handler -> setstate
        e.stopPropagation()
        limit upvote
            
    validation when user submits form 
        conditionally render styles on form depending on both states
            green - correct format (conditions for valid)
                state for valid
                setstate true
                setTimeout - to turn off state
            
            red - incorrect format
                state for invalid
                setstate true
                setTimeout - to turn off state
                return - we don't want the rest of code to execute

    CUSTOM HOOK FOR CONTEXT
        1)encapsulates the validation logic 
        2)allows the validation logic to be reused
        3)once we get context, we avoid initial null value scenario 

    DOWNFALL OF CONTEXT
        If even 1 thing in the values object changes, the whole lot of components will have to re render. 
        
    CREATION OF CUSTOM HOOK FOR DATA FETCHING
         
    
P5 - RMTDEV
--------------

TO LEARN(NEW TOPICS)
    1)React Query 
    2)Cache
    3)Debounce

FEATURES(SECTIONS)
    1)Search jobs
    2)Job List
    3)Job Details
    4)Pagination
    5)Sorting
    6)Bookmarks

INITIALIZE PROJECT
    CLONE REPO  
        git clone https://github.com/ByteGrad/starter-rmtdev.git .

        NO .
            Creates folder with repo name.

        WITH .
            Unloads the files of the repo in the folder we are located in the terminal.

1.1)SEARCH
    Search Component(Controlled Input)
        OnSubmit Handler
            Create handleSubmit function
            e.preventDefault
            e: React.FormEvent<HtmlFormElement>
        searchText state
            const [searchText, setSearchText] = useState<string>("")
        onChange function
            e: React.ChangeEvent<HtmlInputElement>
            setSearchText(e.target.value)
        Input Element
            value={searchText}
    Fetch jobItems on search
        REQUIREMENT
            Should fetch every time the input detects a change, NOT depending if state changes
        WHERE
            useEffect
                Guard Clause
                    !searchText return -> avoid fetching on an empty state in the initial render
                Dependency
                    searchText -> Fetches on the re render caused by the state change with the most recent value
        ANATOMY
            fetchJobItems async function
                !res.ok
                    Throw Error
              setJobItems state to data.jobItems from fetch
1.2)Showing jobItems(search results)
        List state up
            Move searchText & jobItems to App
        Render jobItems
            Prop Drill
                App -> Container -> Sidebar -> jobLst
            jobList
                map jobList and return a <jobListItem/> for every item
            jobListItem
                render jobItem info
    Typing 
        jobItem and jobListItem
    Prevent Prop Drilling
        Children Pattern
            Typing all components using children
                children: React.ReactNode
    Loading 
        State
            const [isLoading, setIsLoading] = useState(false)
        WHERE 
            Before fetch
                true
            After success fetch
                false
        CONDITIONALLY RENDER SPINNER
            {isLoading && <Spinner/>}    -> Only shows spinner if it is loading
            {!isLoading && jobItems.map  -> Only shows ListItems if fetch is no longer fetching
    Type
        JobItem
            exported to types file
        JobList
            Jobitems: JobItem []
            isLoading: boolean
        JobListItem
            jobItem: JobItem
    useJobItems custom Hook
        Objective
            Group all logic related to this feature in a single place
        Benefit
            1)De clutter main app or files unnecessary for this
            2)If implementation wants to be changed, only 1 place to work on
                useEffect
                React-Query
                Other libraries
            3)Re use logic
    Slice jobItems into a Page
        jobItems.slice(0,7)

        WHERE
            useJobItems custom hook
    JobItems to Tuple
        WHY
            Where prop is sent
                Receives type as union number | string
            Where prop is used
                Props is defined as what it should be ideally
        PROB
            Both come into conflict and must be addressed
        SOLU
            Tuple will provide ideal type for each
                return [jobItemsSliced,isLoading] as const
    Key Prop
        Funny enough, it must be given but react won't pass it. 
        It won't be received on the component definition side. 
    Type Form
        searchText: string
        setSearchText: React.Dispatch<React.SetStateFunction<string>>.
2)JOB DETAILS
    Keep track of active job Id
        WHY 
            1)style based on active job
            2)share current id for page to load in that state
        URL HASH
            fulfills requirements to share and load.
            state will lose its value on initial load.

            WRITING
                <a href={`#${jobItem.id}`}
                HOW
                    Window.location.href gets or sets the url.
                    Anchor tags href prop has access to the window.location.href   
            READING
                Tap into hashchange event with an event listener.
                WHERE
                    UseEffect
                HOW
                    window.addEventListener("hashchange", () => {...})
        Initially call to handlehaschange
            if there is something in the hash
            useEffect runs the function without need for hashchange event

            PRO
                Avoids need to set initial value | null in state


        STATE
            const [activeId, setActiveId] = useState<number | null>(null) 
            WHERE
                app, b/c jobList and jobItemContent need it
            WHY
                Hash alone won't cause re renders, it is for data persistance only.
            
    useActiveId custom Hook
        Objective
            Group all logic related to this feature in a single place
        Benefit
            1)De clutter main app or files unnecessary for this
            2)If implementation wants to be changed, only 1 place to work on
    Fetch jobItemContent(Custom Hook)
        WHEN 
            activeId changes
        REMEMBER
            onClick for specific jobItem already deals with changing the hash and the activeId state. We can work with reacting to this change. 
        guardClause
            !activeId return
        Types consistency is enforced
            A type defined before (activeID = number | null) will force you to keep that same type and work around it.

            EXAMPLE
                useJobItemContent(activeId: number | null)
                    type narrow the null case with guard clasue
                    only number type is left to deal with
    type JobItemContent
        perfect example of type intersection
            export type JobItemContent = JobItem & {
            ... extra
        }
        Initial type for JobItemContet useState
            JobItemContent | null
            WHY
                When initialized, there is a scenario in which the fetch is not run b/c activId is not there and has not changed. 
                    In this situation we work with null.

            Guard clause
                Rememember to always guard clause a null state
            Prop does not exist on type never Error
                Error message when state is initialized empty and is not unioned with the actual type
        Importing same name type as component
            import {type JobItemContent}
    Render JobItemContent
        Render EmptyJobContent
            if !JobItemContent return <EmptyJobContent/>
    isLoading
        Multiple isLoading must be in separate files. 
    Style active jobListItem
        inside jobListItem
            useActiveId c-hook
            isActive={activdeId == jobItem.id} -> conditionally render prop to produce boolean value
    ResultsCount
        derived state in useJobItems hook where info is readily available
3)Debounce searchText
    Obj
        Limit api fetch until user has finished typing in input
    HOW
        Fetch with a debounced searchText
    
    STEPS
        useEffect(() => {
            const timerId = setTimeout(() => setDebouncedSearchText(searchText), 1000)
            return () => clearTimeout(timerId)
        },[searchText])
    type with generics
        useDebounce<T>(value:T,delay = 1000):T
    Default params
        Perfect use for a standard delay unless user specifies.
4)Changing fetch to React-Query
    Obj
       Store recently fetched data to avoid re fetching
    WHERE
        1)jobItems
        2)jobItemContent
    PROVIDER
        Establish a provider in the main file with <App>
    FETCHER FUNCTION
        Extracted named function 
    type assertion for null case of a type 
        Good way to deal with the datatype | null guard clause
    typing data from react query
        SOLU
            type data returned from fetcher function
    typing fetch function 
        Promise<JobItemContent>
    Error handling
        Pass the error
        Use the error
            onError: (error) => {
                console.log(error)
            } 
    Purify the function
        Remove derived states to maintain the function pure
    Refactor the useJobItems Hook
        Possibility of undefined
            If funcion is never run, the returned data could be undefined. 
            SOLUTION
                Just like before, give it an initial value.
            EXAMPLE
                initialData: [], // Ensures data starts as an empty array
            WHAT HAPPENS
                Data will never be undefined, always empty array or full array
        Possibility of undefined values that are being sent with one data type | undefined and where they are used they are defined as without undefined.
            Short circuit the negative case scenario
                const jobItemsSliced = jobItems?.slice(0 ,ITEMS_PER_PAGE) || []
                 const jobItemsCount = jobItems?.length || 0
4)Add toast messages
    Use library
        <Toaster position="top-right"/>
        toast.error={message}
    Type narrow the message passed to toast for ts
        WHY
            React query error param is unknown type. Ts hates this.
        HOW
            let message 
            if(error instanceof Error){
            message = error.message
            }
            else if(typeof error === "string"){
            message = error
            }
            else{
            message = 'An error occured.'
            }
            toast.error(message)
        THINK OF IT THIS WAY
            ts needs proof what you are doing is allowed and you must proof it is of that type for him to allow it.
    Create error util function 
        For reusability purposes move the entire function to the utils and import in the hook.
5)Pagination
    Set the components
        import the radix arrow components
    State to store page
        const [currentPage, setCurrentPage] = useState(1)
        WHERE
            App b/c jobItem to slice by page is there already.
    Create previous and next page functions for the buttons
        const handleChangePage = (pagination: 'previous' | 'next') => {
            if(pagination === 'previous'){
            setCurrentPage((prev) => prev - 1 )
            }
            else if(pagination === 'next'){
            setCurrentPage((prev) => prev + 1)
        }
        WHY
            specific due to error in providing the parameter
    render previous and next page in buttons
        send currentPage as prop to paginationControls
        {currentPage -1}{currentPage +1}
    conditionally render previos and next buttons
        previous
            {currentPage > 1 && previousButton}
        next
            derive last page
                const lastPage = jobItemsCount / ITEMS_PER_PAGE

            {currentPage < lastPAge && nextButton}
    create custom paginationButton component
        conditionslly render page and arrow based on direction 
            {direction === "previous" && (
                <>
                Page {page - 1}
                <ArrowLeftIcon />
                </>
            )}
        conditionally style the class for the next button only
            className={`pagination__button ${
                direction == "next" ? "pagination__button--next" : ""
            }`}
        type using almost same types and invoke the function 
    derived pagination state
        const lastPage = jobItemsCount / ITEMS_PER_PAGE;
    use pages to determine the slice of jobitems to render
        const jobItemsSliced =
            jobItems?.slice(
            currentPage * ITEMS_PER_PAGE - ITEMS_PER_PAGE,
            currentPage * ITEMS_PER_PAGE
        ) || [];
6)Sorting
    By:
        1)recent | daysAgo
        2)relevance | relevanceScore
    STATE
        const [sortBy, setSortBy] = useState<'relevant' | 'recent'>('relevant')
    WHERE
        App b/c it will be used to sort jobItems
    ORDER
        1)fetch
        2)sort
        3)paginate
    handleSortBy function
        const handleSortBy = (sortOption: 'relevant' | 'recent') => {
            setSortBy(sortOption)
        }
        back to first page
            setCurrentPage(1)
    style active sort option class
        sortOption === 'recent' | 'relevant' ? sorting__button--active : ""
    sort jobList based on sortBy
        [...(jobItems|[])].sort()
            To work on a brand new array and not modify the existing.
        a - b
            less to more
        b - a 
            more to less
        always specify default return like in switches
            return 0 in this case
        guard clause
            if jobItems is undefined || []
    render based on jobItemsSorted
        jobItemsSorted?.slice(pages)
    create & use SortBy & Direction types
        import { Direction, SortBy } from "../lib/types";
        export type SortBy = 'relevant' | 'recent'
        export type Direction = "previous" | "next"
    
7)Bookmarking
    WHAT
        Keep log of bookmarked jobs
    WHERE
        LocalStorage
    BookmarkIcon
        create state to store bookmarkedIcons
            const [bookmarkedIds, setBookmarkedIds] = useState<number>([])
        create handle toggleBookmarks
            if !bookmarkedIds.includes(id)
                add it 
            else
                remove it
        Context API
            WHY
                1)used in jobListItem & JobItemContent
                2)too many levels too drill app -> list -> item -> bookmarkIcon

            create context
                const BookmarkContext = createContext<BookmarkContextProps | null>(null);
                    1)bookarmedIds state
                    2)handleToogleBookmarks
            wrap context around app
                ReactDOM.createRoot(document.getElementById("root")!).render(
                    <React.StrictMode>
                        <QueryClientProvider client={queryClient}>
                            <BookmarkContexProvider>
                                <App />
                            </BookmarkContexProvider>
                        </QueryClientProvider>
                    </React.StrictMode>
                );

            type context & context provider
                type BookmarkContextProps = {
                    bookmarkedIds: number[]
                    handleToggleBookmark: (id:number) => void
                }
                type BookmarkContextProviderProps = {
                children: React.ReactNode
                }
            create custom hook for useBookmarkedIdsContext
                export const useBookmarkedIdsContext = () => {
                const context = useContext(BookmarkContext)
                if (!context) {
                    throw new Error(
                    "BookmarkedIds context needs to be used inside the provider"
                    );
                }
                return context;
                }
            consume context in jobListItem & JobItemContent
                const {bookmarkedIds, handleToggleBookmark} = useBookmarkedIdsContext()
        Send id to bookmark icon
            jobListItem
                <BookmarkIcon jobItemId={jobItem.id}/>
            jobItemContent
                <BookmarkIcon jobItemId={jobItemContent.id}/>
        Use toggler
            <button className="bookmark-btn" onClick={() => handleToggleBookmark(jobItemId)}>
        Conditionally stle filled class
            <BookmarkFilledIcon className={bookmarkedIds.includes(jobItemId) ? "filled" : ""}/>
        StopPropatation and preventDefault
            Anchor default behavior will always be to go to specific place.
            e.stopPropagation()
            e.preventDefault()
        Local Storage
            Write
                useEffect
                    b/c it is an exeternal system
                  useEffect(() => {
                    localStorage.setItem('bookmarkedIds', JSON.stringify(bookmarkedIds))
                }, [bookmarkedIds])
            Read
                1)read from LS
                    const bookmarksFromLocalStorage = JSON.parse(localStorage.getItem("bookmarkedIds") || "[]")
                WHY
                    structure of array needs to be in string before converted
                2)set initial state to the search from LS
                      const [bookmarkedIds, setBookmarkedIds] = useState<number[]>(bookmarksFromLocalStorage);
                3)change initial state to function to avoid on every re render
                    const [bookmarkedIds, setBookmarkedIds] = useState<number[]>(() => JSON.parse(localStorage.getItem("bookmarkedIds") || "[]"));
        use LS custom hook 
            purpose
                1)Persist any data not only the bookmarks
                2)De clutter main app and enmcapsulate logic for reusability
            Implementation
                1)create state and initialize if reading from LS
                2)write with it on a useEffect to LS
                3)return state and setState functions
            type custom hook with generics
                export function useLocalStorage<T>(key:string, initialValue:T):[T, React.Dispatch<React.SetStateAction<T>>] 
                    ...
                }
        
    BookmarkButton && BookmarkPopup
        Obj
            fetch full data of job based on ids of bookmarkedIds in LS

        State controlling
            const [isOpen, setIsOpen] = useState(false)
        Function toggling     
            const togglePopOver = () => {
                setIsOpen((prev) => !prev)
            }
        Conditionally rendering
            Anywhere b/c of its CSS
            {isOpen && <BookmarksPopover/>}
        Render jobList inside bookmarks popover
            <JobList jobItems={[]} isLoading={false}/>
        rename useJobItems to useSearchQuery
            Appropriate name for the function.
            UseJobItems should be the plural of useJobItemContent and work with Ids.
        create useJobItems hook to fetch multiple jobItems based on Id
            export function useJobItems(ids: number[]){
                const jobItems = useQueries({
                    queries: ids.map((id) => ({
                    queryKey: ["job-item", id],
                    queryFn: () => fetchJobItemContent(id),
                    staleTime: 1000 * 60 * 60,
                    refetchOnWindowFocus: false,
                    retry: false,
                    enabled: !!id,//on mount condition to run, if id run.
                    onError: handleUnknownError // auto passed parameter
                    })),
                })
                console.log(jobItems)
                return jobItems
            }
        Transform the result and filter out the undefined
            const jobItems = results.map((result) => result.data).filter((jobItem) => jobItem !== undefined)
        Add to context Type 
            bookmarkedJobItems: JobItemContent[]
        Create global isLoading based on individuals isLoading
              const isLoading = results.some((result) => result.isLoading)
        IN bookmarks context, use the hook with the already saved bookmarkedIds array
            const [bookmarkedJobItems, isLoading] = useJobItems(bookmarkedIds);
        Add these bookmarkedJobITems to the context to be distributed
            value={{
                bookmarkedIds, handleToggleBookmark,bookmarkedJobItems,isLoading
            }}>
        Use This newly shared bookmarkedJobItems in the BookmarkPopover
            
       LAST  modify bookmarks context to useJobItems with bookmarksId
            const {jobItems, isLoading} = useJobItems(bookmarkedIds)

         LAST consume the bookmarks context to retrieve bookmarkedIds
            const {jobItems, isLoading} = useBookmarkedIdsContext()

        Close popover on clicking outside
            Obj
                Clicking outside the popover will close it
            HOW
                Use popover as basis and whenever you click outside it, make it close.
            1)e.target.closest('.class')
                useEffect()
                    const handleClick = (e) => {
                        if (
                            e.target instanceOf HTMLElement && 
                            !e.target.closest(".bookmarks-btn") &&
                            !e.target.closest(".bookmarks-popover")
                        )
                            setIsOpen(false);
                        };
                        document.addEventListener("click", handleClick);

                        return () => {
                        document.removeEventListener("click", handleClick);
                    };
                DOWNSIDE
                    Too dependent on classes, if they change everything changes.
            2)useRef()
                create refs
                    const buttonRef = useRef<HTMLButtonElement>(null)
                    const popoverRef = useRef<HTMLDivElement>(null)
                use refs in conditionals
                    if (
                        e.target instanceof HTMLElement && 
                        !buttonRef.current?.contains(e.target) &&
                        !popoverRef.current?.contains(e.target)
                    )
                provide refs to elements
                    <button ref={buttonRef}>
                    <BookmarksPopover ref={popoverRef}/>
                consume ref on the bookmarks popover
                    const BookmarksPopover = forwardRef(function(props, ref) {
                    return <div ref={ref} </div>;
                    })
                    export default BookmarksPopover
                type the ref
                    as usual generics in the function provided by react

                    forwardRef<HTMLDivElement>
                how would you type the props
                    forwardRef<HTMLDivElement, {here}
                irony
                    typing
                        ref = 1 
                        props = 2
                    function parameters
                        props = 1
                        ref =2 
                custom hook 
                    What do we need to pass?
                        1)refs in []
                        2)function to execute
                    Iterate over refs and make 1 functin to execute for all
                        refs.every((ref) => !ref.current?.contains(e.target))
                Final Product
                    export function useClickOutside(refs, handler) {
                        useEffect(() => {
                            const handleClick = (e: MouseEvent) => {
                            if (
                                e.target instanceof HTMLElement && 
                                refs.every((ref) => !ref.current?.contains(e.target))
                            )
                                handler()
                            };
                            document.addEventListener("click", handleClick);

                            return () => {
                            document.removeEventListener("click", handleClick);
                            };
                        }, [refs, handler]);
                    }
                Type the refs and the handler
                    Typing
                        refs:React.RefObject<HTMLElement>[], handler: () => void
                    Asserting
                        e.target as Node
                    
8)Performance optimizations
    1)useActiveID
        PROBLEM
            Whenever it is used, all code will run again. 
                1)useeffect will run
                2)usestate will be created several times
                3)eventlisteners will be created several times
            Currently used in 2 places:
                1)JobItemContent(to indicate which jobItem to fetch)
                2)JobItemList(indicate which item to highlight as active)
        SOLUTION 
            Context it so only 1 exists and can be shared.
        PROCESS
            create ActiveIdContextProvider component
                1)export const ActiveIdContext = createContext<ActiveIdContext | null>(null);
                2)export default function ActiveIdContextProvider({children}: ActiveIdContextProviderProps) {
                    const activeId = useActiveId();
                    return <ActiveIdContext.Provider value={{activeId}}>
                        {children}
                    </ActiveIdContext.Provider>;
                }
            create useActiveIdContext Hook for boilerplate guard clause code
                export const useActiveIdContext = () => {
                const context = useContext(ActiveIdContext)

                if (!context) {
                    throw new Error(
                    "useActiveIdContext needs to be used inside the provider"
                    );
                }
                return context;
                }
            wrap around app
                This is where the context provider hell comes from
                    <React.StrictMode>
                        <QueryClientProvider client={queryClient}>
                            <ActiveIdContextProvider>
                                <BookmarkContexProvider>
                                    <App />
                                </BookmarkContexProvider>
                            </ActiveIdContextProvider>
                        </QueryClientProvider>
                    </React.StrictMode>
            consume
                const {activeId} = useActiveIdContext()
                    1)JobItemContent    
                    2)JobList
        RESULT
            State is created only once
            Event listeners are attached only one
            Data is maintained pure and shared
        
    2)Pulling everything from the App component(context everything)
        PROBLEM
            state will cause anything in that component and its children to re render. (Basically all the app)
        LESSON
            Try the most you can to avoid re calculating array calculations.(very expensive)
        A)Search Text
            a)create searchTextContextProvider component
                1)move searchText and debouncedSearchText to here
                2)provide value={{searchText, debouncedSearchText, setSearchText}}
            b)create useSearchTextContext
                useContext(searchTextContext)
            c)consume useSearchTextContext everywhere we need 
                1)jobItems requres debouncedSearchText, we can't put it in app must create context
                2)form(provides searchText, setSearchText)
        B)JobItems
            a)create JobItemsContexyProvier
                1)move jobitems, sortby, currentPage
                2)provide all of it
            b)create usejobitemscontext
                useContext(jobItemsContext)
            c)consume useJobItemsContext
                1)jobList
                2)paginationControl
                3)sortingControl
                4)ResultsCounter
            d)Special case due to giving it different information
                BEFORE
                    a)app
                        We were giving it the whole joblistitemsliced
                    b)boomkarkpopover
                        We were giving it the whole bookmarkedJobItems
                NOW
                    a)App
                        <JobListSearch/>
                            Data
                                const {isLoading, jobItemsSliced} = useJobItemsContext()
                            Render
                                <JobList jobItems={jobItemsSliced} isLoading={isLoading} />
                    b)BookmarkPopover
                        Data
                            const { bookmarkedJobItems, isLoading } = useBookmarkedIdsContext();
                        Render
                            <JobList jobItems={bookmarkedJobItems} isLoading={isLoading} />
    3)useMemo(Memoize derived state)
        Efficiency in 2 steps = avoiding unnecessary
            1)re - renders
                Already worked on by encapsulating and contexting everything.
            2)computations
                There could still be some things that even if the component re renders, complete recalculation may not be necessary.
        1)Sorted case
            PROBLEM
                Since everything is in context, sorted calculation may run if page state changes and it     
            shouldn't b/c sort runs before slicing. Page changes but the items are already correctly sorted.

            SOLUTION
                Memoize unless JobItems or sortby change. No need to re run if page changes.
        2)Splice case
            PROBLEM
                None really, no case exists where this is not necessary to re run but oh well
            SOLUTION
                Memoize LOL
        3)Context Value case
            PROBLEM
                when state in context changes, return value is recalculated and all consumers re render entirely independent of what value changed b/c it recalculates all of it.
        4)Callbacking functions
            PROBLEM
                function gets re created on every render with new reference in memory, meaning the memo will detect it as a new changed one and re calculate everything. It defeats the purpose of the memo, having functions not callbacked.
            SOLUTION
                useCallback(useMemo but for functions)
                
            
            
        
        
                

        
        
            
                
            
        
                





        
    
            


            

        
                

        
            
            

            
                           
    
----------------
NEW TOOLS
    React Query
        Powerful library to manage state and fetching.

        WHY
            Automaically handles all the manual things you are used to doing:
                1)loading 
                2)errors
                3)caching
                4)refetching stale info
        COMPARISON
            WITHOUT
                useEffect -> fetch
                useState -> result
                useState -> loading
                useState -> errors
                manual re fetch for stale info
            WITH
                useQuery hook
        INSTALL
            npm install @tanstack/react-query
        SETUP QUERY CLIENT IN MAIN FILE
            import {QueryClient, QueryClientProvider} from "@tanstack/react-query"

            const queryClient = new QueryClient()

            function App() {
                return(
                    <QueryClientProvider client={QueryClient}>
                        <...>
                    </QueryClientProvider>
                )
            }
            WHAT HAPPENS
                Query client wraps around your app and enables caching for all app.
        FETCH DATA WITH USEQUERY
            import {useQuery} from "@tanstack/react-query"

            function MyComponent() {
                const {data,error,isLoading} = useQuery({
                    queryKey: ['key'], 
                    queryFn: async () => {
                        const response = await fetch("https://your-api.com/data");
                        if (!response.ok) {
                        throw new Error("Network response was not ok");
                    }   
                        return response.json(); // Return the parsed JSON data
                    },
                    staleTime: 1000 * 60 * 5, 
                    cacheTime: 1000 * 60 * 10,
                    refetchOnWindowFocus: false, // 
                })
            }
            PARAMS
                queryKey                -> unique key to remember query for caching
                queryFn                 -> fn that fetches
                isLoading               -> true while fetching
                error                   -> request fails(500)
                data ->                 -> data response
                staleTime               -> (Optional) Keep data fresh
                cacheTime               -> (Optional) Keep data in cache
                refetchOnWindowFocus    -> (Optional) Prevent refetching when window regains focus
                enabled                 -> (optional) Run on mount? (boolean)
                onError                 -> func to run when error occurs 
            RETURNED
                Property	Type	        Description
                data	    Object / Array	The response data from the API.
                error	    Object / null	The error object if the request fails.
                isLoading	Boolean	        true while the query is fetching for the first time.
                isError	    Boolean	        true if an error occurred.
                isFetching	Boolean	        true if React Query is refetching data in the background.
                refetch	    Function	    A function to manually trigger a refetch.
        IMPROVEMENTS
            1)No more manual state handling(isLoading, Error, Data)
            2)Cache
            3)auto updates stale data
            4)No need for custom try catch
        DIFF isLoading vs isInitialLoading
            isLoading: 
                true when the query has no cached data and is fetching.
                This means while we haven't fetched, it is true and spinner forever.
            isInitialLoading: 
                true only while fetching and then false forever.
            RESULT
                If the query refetches (e.g., due to enabled changing or a manual refetch), isLoading might be true again, but isInitialLoading will remain false.
        INITIAL RETURNED DATA BEFORE FETCH
            React query does not know what to return, so it returns UNDEFINED.
        PLACEHOLDERDATA
            it gives React Query a temporary value (in this case, an empty array []) while the actual data is being fetched. 
            LIKE SAYING
                NOW - assume an empty array
                LATER - i'll change it after the fetch is done
            BENEFITS
                No dealing with undefined
        USEQUERIES
            Way to make several fetches in paralell instead of waterfall
            Each querie has its individual data,loading,error.

            SYNTAX
                const jobItems = useQueries({
                    queries: ids.map((id) => ({
                    queryKey: ["job-item", id],
                    queryFn: () => fetchJobItemContent(id),
                    staleTime: 1000 * 60 * 60,
                    refetchOnWindowFocus: false,
                    retry: false,
                    enabled: !!id,//on mount condition to run, if id run.
                    onError: handleUnknownError // auto passed parameter
                    })),
                })
                console.log(jobItems)
                return jobItems
        
        
    REACT HOT TOAST
        Customizable react library for toast notifications.

        FEATURES
            lightweight and fast
            auto dismissable
            customizable
            promise support
            works anywhere
            
        INSTALL
            npm install react-hot-toast
        USAGE
            import { Toaster, toast } from 'react-hot-toast';

            function App() {
                return (
                    <div>
                    <button onClick={() => toast('Hello, world!')}>Show Toast</button>
                    <Toaster />
                    </div>
                );
            }
            export default App;
        TYPES
            1)toast.success('Successfully saved!');
            2)toast.error('Something went wrong!');
            3)Custom Toast with Loading Indicator
                toast.promise(myPromise, {
                    loading: 'Loading...',
                    success: 'Data loaded!',
                    error: 'Error loading data!',
                });
            4)Custom Styling
                toast('This is a custom toast', {
                    duration: 4000,
                    position: 'top-right',
                    style: {
                        background: '#333',
                        color: '#fff',
                    },
                });

    createPortal()
        createPortal lets you render some children into a different part of the DOM.

        SYNTAX
            {createPortal(children, domNode, key?)}
        
        WHERE DOES IT END UP
            Literally outside the .root
        
        


LEARNED - SUMMARY
    cacheing
        storing frequently accessed data in a temp storage location to reduce retrieval time and improve performance. 
        POPULAR WAYS
            1)react-query
            2)nextjs
            3)swr vercel
    clone repo to here
        git clone https://github.com/ByteGrad/starter-rmtdev.git .
    sharing repo    
        package.json to install node_modules and avoid uploading the massive folder 
    icon to use action
        wrap icon in a button 
            example
                BookmarkIcon
                BookmarkButton
    reusability even in small components
        BookmarkIcon component 
    logo to start page
        wrap image or icon in anchor tag 
        Children prop to encapsulate html tags
        create component that will use a div to wrap around children. This encapsulates logic.
        EXAMPLE
            export function SidebarTop({children}: {children: React.ReactNode}){
                return (
                    <div className="sidebar__top">
                    {children}
                    </div>
                )
            }
    FETCHING BASED ON PURPOSE
        onLoad
            useEffect
                state as dependency
                    state changes:
                        1)component re renders
                        2)state is given as input value
                        3)useEffect runs again and fetches based on most recent state value
        onReaction
            onChange(equivalent event)
    Params
        Query
            resource located, need to filter further
            example
                search
                sortBy
                limit
        Path(Route)
            locate specific resoure
    Never Type
        Ts type that represents a value that never occurs. 
        Expression will never produce a value.
        Ts will infer this value when initializing an empty array [].
    Loading state
        isLoading && <Spinner/>
            Always needed
        !isLoading && Data.map
            Prevents niche cases of previous fetch data existing and new fetch being loaded
    How custom hooks work
        HOW
            By following proper hook logic, we guarantee it will work as if it is not there
        Objective
            Group all logic related to this feature in a single place
        Benefit
            1)De clutter main app or files unnecessary for this
            2)If implementation wants to be changed, only 1 place to work on
                useEffect
                React-Query
                Other libraries
            3)Re use logic
    Returning array from custom hook
        SITUATION
            Where prop is sent
                Receives type as union number | string
            Where prop is used
                Props is defined as what it should be ideally
        PROB
            Both come into conflict and must be addressed
        SOLU
            Tuple will provide ideal type for each
                return [jobItemsSliced,isLoading] as const
    Key Prop
        Funny enough, it must be given but react won't pass it. 
        It won't be received on the component definition side. 
    Window object
        Global namespace with global variables and functions as properties.
        
        1)size and position
        2)document and DOM access
            .document  -> html DOM
            .location  -> current URL(protocol, hosty)
                1).href      -> get or set URL  
                2).reload()  -> reload page
                3).assign()  -> navigate to new URL
                4).replace() -> replaces in url in history, no back option  
            .history   -> browser session history
            .navigator -> browser and device info
    Window.location.hash
        Fragment identifier in a URL, part after the #.
        Write
            window.location.has = "jobId"
        Read
            const id=window.location.hash.substring(1)
        Reacting to hash change
            window.addEventListener("hashchange", () => {...})
    Returning function in useEffect
        Remember to clean up after side effects
    Types consistency is enforced
        A type  defined before (activeID = number | null) will force you to keep that same type and work around it. (useJobIems(activeID))
    Excellent useCase for Type Intersection
        Types where you fetch surface info on list
        And then fetch details for the details page
    Importing same name type as component
        import {type JobItemContent}
    State<type | null> and Type Narrow
        Always make sure you contemplate the null case of the state first
        When you look for something inside state, if null is not dealed with first, it will give error.
    isLoading
        Multiple isLoading must be in separate files.        
    Order of logic / conditional 
        Negatvie cases first
            isLoading?
            !var
            positive return for component
    Debounce searchText
        Technique to limit # of times a function is executed.
        Ensures function is only executed after a specific delay.
        HOW
            1)each time event is triggered, timer is set.
            2)if event is triggered before timer ends, time restarts.
            3)func executes only after timer has finished wihtout interruptions.
        WHEN
            1)search input
            2)button click prevention
            3)windowx resize
    C-hooks library
        usehooks-ts.com
    Tip when determining where to locate hooks or functions
        Look at where you already have access to data

        EXAMPLE
            debouncesearchtext can be in app b/c searchtext is already there.
    SetTimeout in Reac
        Accumulated timeouts will execute.

        SOLUTION
            Removal of each of the unnecessary calls. 
            1)store id of each
            2)return a function that executes clearTimeout with that id.
    Non-Null Assertion (!)
        The non-null assertion operator (!) tells TypeScript:
            I am 100% sure this value is NOT null or undefined.
            Use with cautionit bypasses TypeScripts safety checks.
        HOW TO USE
            cases in which type is something | null as substitute for guard clause
        GOOD EXAMPLE
            Inside react query query-fn to avoid guard clausing the number | null activeID
    Sending complex info as prop
        If it is a list, and you are rendering a component, send the entire object as an item and destructure on the other side. 
    Typing API Resp
        Use Promise Generic
            Promise<>
        Type your data
           Type = Data 
        Use the data as the type for the Promise Generic
            Promise<Data>
    Using !resp.ok
        Can save you an unnecessary guard clause.
        HOW
            If fetch depends on paramater that can be null: data | null, it handles this case for you.
        RESULTING TYPE NARROW
            Allows ts too infer that null case is handled, and data will always be truthy
    what browser does in the 500 errors
        Automatically throws Error() like we do in the other server codes\
    Possibility of undefined, methods depending on value being array 
        ?. optional chain
        Establishing the undefined case means type will be type | undefined
            PROBLEM
                In the other side, data has not been typed as counting the undefined scenario
            SOLUTION
                Short circuit ||
                    if undefined || [] / 0
    Unknown ts type
        opposite of any, can't do anything, everything throws errors.

        WHY
            type of paramter for the onError function of React Query can be anything even though react hot toast expects a specific type.

            FIX
                Ts needs to specifically know what it is dealing with at all times.
                Type narrow 
            EXTRA DATA
                React Query new versions make the error parameter the default Error object type.
    Client vs server side pagination
        client
            Implemented client, all calculations done on the clien
            Receive entire package of data
            can slow down the client if too much data
        server
            server only sends the data for that page, fetches every page.
            better for massive data
    Ts literal + union type good use
        const [sortBy, setSortBy] = useState<'relevant' | 'recent'>('relevant')
    [...(jobItems || [])]
        for mutating methods its best to destructure and create a new
        must guard for undefined case and assure that an empty array will be returned []
    Can use variables to seend booleans as props
        isActive={sortOption === "relevant"}
    e.stopPropagation() special anchor behavior
        e.preventDefault()
    LS in useEffect
        IF NOT
            async nature of state will make it really hard to have properly synced.
        IF 
            Will be in sync without much hastle
    Function as initial value in useState
        BENEFIT
            Only runs on mount, avoids needless computation on every re render.
    Typing a prop and passing that data + more
        Ts will not complain as long as what was specified is included minimum
        You can configure ts too complain
    e.target.closest(".classname")
        Returns true if event comes from within the element with the classname provided
    Refs
        Passing a ref as a prop and consuming
            1)ref is received separate from props
            2)must wrap component in forwarefRef(function(props, ref){
            })
        Type the ref
            Generics in the function provided by react
                forwardRef<HTMLDivElement>
        Type the prop
            forwardRef<HTMLDivElement, {here}
        Irony in placement
            typing
                ref = 1 
                props = 2
            function parameters
                props = 1
                ref =2 
    Indicating a required parameter will not be used
        _
        function(_, ref)
        This way the eslint or ts error message will stop appearing.
    Features so common there are custom hooks already
        1)useDeounce()
        2)useLocalStorage()
        3)useClickOutside()
    Trick when refactoring a function into a custom hook
        Generalize the already specific result
    createPortal
        Way to locate pop ups and popovers in the entire document.body while still having them in the component they should be in.
    Wrapper for reusable Component
        Create a wrapper and render reusable component inside to provide the data through props
        Implementation
            App
                <JobListSearch/>
            JobListSearch
                Data
                    const {isLoading, jobItemsSliced} = useJobItemsContext()
                Render
                    <JobList jobItems={jobItemsSliced} isLoading={isLoading} />
            BookmarkPopover
                Data
                    const { bookmarkedJobItems, isLoading } = useBookmarkedIdsContext();
                Render
                    <JobList jobItems={bookmarkedJobItems} isLoading={isLoading} />
    Efficiency = avoid unnecessary
        1)re renders
            a)context and encapsulation with states 
        2)calculations
            a)use memo to avoid calculating unless dependencies change
    Importance of updating objects and arrays with new ones
        If done on the original (ex: sorting), the reference to that variable does not change. 
        MEANING
            Dependencies will not be triggered by the change in it, b/c they will register as if it is the same.
    
    
        





    
        

        
        
    
    

    
        
    
    
        
        
            


    
                


    
    
    
            

        



                    




        



        





        


-->
