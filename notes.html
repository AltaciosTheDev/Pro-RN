<!-- 
CONCEPT RECAP
    1)jsx
    2)fragments
    3)components
    4)props
    5)event handlers
    6)hooks
    7)shortcuts (rfc)
    8)useState - renders 
    9)useEffect - side effects 
    10)() return several lines
    11)`` ${} template literals
    12)return -> exit from function 
    13)... -> spred operator
    14)&& short circuiting 
    15)style={{fontStyle="50px"}}
    16)every component could import its own css file 
    17)let,var,const
    18)controlled input

SIMPLE LOGGIC BEHIND LOADING A WEB PAGE
    1)client requests url to server
    2)server serves the index.html
    3)index.html links to all the static files(fonts, images, stylesheets,favicon)
    4)client will make network request for all those static files

NEW KNOWLEDGE
    1)arrow funcs need to be exported at the end of the file
    2)"react/prop-types":"off"

PROJECT 1 - FANCY COUNTER
    CREATE PROJECT WITH VITE
        npm create vite@version
        npm install
        npm run dev

    PAKCHAGE JSON
        All important information about the project(versions, commands, dependencies)

    ESLINT
        Can install extension but config file will take precedence.

    HOW CAN PEOPLE GET NODE_MODULES
        npm install
            installs dependencies on the package.json
        .gitignore
            holds the node_modules so they are not commited or shared

    WHERE TO STORE IMAGES
        src
            assets
                if they are referenced
        public
            if they are not referenced

    AUTO IMPORTS
        ctrl+enter -> should pop up intellisense

PROEJECT 2 - WORD ANALYTICS
    TO LEARN
        Character analyzer to see how many characters are left in a post for social media.
    
    CREATE PROJECT
        npm create vite@version . 

    TRIIGGER INTELLISENSE
        ctrl + space
        enter

    REMEMBER SEMANTIC HTML
        <header>
        <footer>
        <main>
        <section>

    REMEMBER RETURN
        return from negative paths to prevent rest of code to execute
        
    DON'T NEED TO ADD MORE STATE
        Analyze if states are very closely related and eliminate one. 
        Boolean state is not necessary, we can condition with trushy and falsy states.
    
    DERIVED STATE
        Calculations based on an existing state.
        Avoids overpopulating with more states.

    LIFTING STATE UP 
        To parent component that can distribute to all children in need.

    PASSING PROPS AS DESTRUCTURED OBJECT
        Passing a lot of props gets messy and tedious.

        const stats = {
            numberOfWords: text.split(/\s/).filter((word) => word !== "").length,
            numberOfCharacters: text.length,
            instagramCharactersLeft: 280 - text.length,
            facebookCharactersLeft: 2200 - text.length,
        };

        <Stats
            {...stats}
        />

    CONDITIONAL STYLING IN REACT
        className={`original clases ${var ? "classToRender" : ""}`}

    EXTRACTING CONSTANTS IN SEPARATE FILE
        Every single constant value, in separate constants.js file.
        
        EXAMPLE
            export const INSTAGRAM_MAX_CHARACTERS = 280
            export const FACEBOOK_MAX_CHARACTERS = 280
    
    FOLDER STRUCTURE
        paths must be relative to the main.jsx

        COMPONENTS
            all react components
        LIB
            constants
            hooks
            utilites

INTERMEDIATE REACT & JAVASCRIPT
    ARRAYS - INTERMEDIATE
        push
        length
        .forEach
        item[#]
    OBJECTS - INTERMEDIATE
        nested objects
        property shorthands
    ARRAYS - ADVANCED
        .push()
        .map() - returns new array - always specify return keyword
        .some() - returns true if at least 1 element fulfills condition - always specify return keyword
        .find() - returns 1st element or undefined - always specify return keyword
        .filter() - returns new array with elements that specify condition - always specify return keyword
    
    OBJECTS - ADVANCED
        bracker notation 
            object[property]
    SPREAD OPERATOR
        const totalArry = [...arr, ...arr2]
    DESTRUCTURING
        const {name} = user -> must be same name
        const [anything] = cart -> order is what matters
    PRIMITIVES VS REFERENCES
        only primitives can be compared(== || ===)
        reference -> you get pointers to where the data is stored -> thats why they can't be compared
    SHORT CIRCUITING && --
        && -> super consice if this is true, run the right part.
        || -> if first is true, stop there. If first is false, run second.
    FUNCTIONS - INTERMEDIATE
        order of execution 
        refactoring -> get rid of redundant code always
        early return -> stops function execution
    FUNCTIONS - ADVANCED
        callbacks -> function as parameter
        method -> function on something
            this keyword only works on traditional function (not arrows)
        default param
            could avoid undefinde in a math operation
    FETCH - INTRO
        words we can type without error are browser included:
            fetch()
        json -> syntad used by client - server communication 
            readable
            supported by most prog-langs
        .then()
            handles a promise -> must return 
        .catch()
            handles errors from the server
        if(!res.ok) -> method that comes with fetch promise -> indicates if response status is in the 200s. This is necessary b/c .catch won;t always catch all errors.
        
    ASYNC - AWAIT
        More modern syntax

        try{
            res = await fetch 
            data = await res
        }
        catch{
            errror
        }

    CUSTOM HOOKS
        Functions that incorporate default hooks + additional logic

        WHERE TO PUT
            hooks folder
                specific hook file

    RULES OF HOOKS
        NOT IN 
            loops
            conditions
            nested functions
            after early return statement

PROJECT 3 - TREKBAG 
    FEATURES
        add items in form (done)
        delete items (done)
        check items (done )
        sort
            pack
            unpacked
            default 
        reset to initial (done)
        mark all as complete(done)
        mark all as incomplete(done)
        remove all items(done)
        localstorage for data persistence
        counter

    TO LEARN
        context api
        zustand
    
    ESLINT
        Pop linting tool for js and ts. 
        Finds potential bugs by analyzing files and flagging issues based on predefined or custom rules.

    ESLINT-PLUGIN-REACT
        specifically for react.
        same as normal eslint but related to react and jsx.
    ESLINT-PLUGIN-REACT-HOOKS
        enforces rules of react hooks.
        ensures popular hooks are used correctly following react guidelines.

    LOOP
        ALWAYS loop when you are repeating your code.
    
    STATIC DATA
        If in file, store outside component definition

    EMOJI POP UP MODAL
        windows + . 
    
    NEW DATE().GETTIME()
        Can be used as a substitute for an id in an object in a database

    useRef()
        1)Hook to literally hook in a ref for an element in the browser.
        2)Save values without triggering re renders
        

    TOAST instead of ALERTS
        more professional

    IMPLEMENTATION LOGIC AND STATE IN 1 PLACE
        Standard practice to keep in 1 place:
            state
            derived state
                normal arithmetic logic on existing state
            logic handlers

    onEvent - onHandleEvent
        When the prop reaches the component that will make use of it,change naming to onEvent to keep html standards.

    SORTING
        1)place component
            React-Select Library
                Represents a whole new approach to developing powerful React.js components that just work out of the box, while being extremely customisable.
        2)Set props
            onChange
            options
            setDefaultValue
        3)make UI change depending on the sortState
            create sort state
            sort array
            map sorted array 
    
    LOCALSTORAGE
        Store items
        UseEffect
        initialize state with return from lc || initial data if lc empty

    USEMEMO
        hook in react to avoid doing recalculation by storing a computation in memory until dependencies change. 
        SYNTAX
            Same useEffefcct syntax
        WHY
            Avoid recalculating taxing stuff on every re render, only when deps change.
        SIMILAR TO
            not wanting to run useeffect on every re render b/c of performance


    CHILDREN COMPOSITION
        Pretty much just move the components higher and bloat up higher to avoid prop drilling.

    CONTEXT
        Hook that allows for the transport of information. 

        1)CREATE CONTEXT COMPONENT
            <ItemsContextProvider>
            1.1)Outside that component definition createContext
                const ItemsContext = createContext()

            1.2)return the context.provider
                return(
                    <ItemsContext.Provider value={{objWithData}}>{children}</ItemsContext.Provider>
                )
        2)WRAP ELEMENTS WITH CONTEXT
            <ItemsContextProvider>
                <everything else>
            </ItemsContextProvider>
        3)export and consume the context from somewhere
            1)export it from the file where it was created
                export ItemsContext = createContext()
            2)consume it
                const {this,that} = useContext(ItemsContext)

        PROBLEMS
            No selectors, meaning every component attached to a part of context will always render if 1 of them change. 
            Big apps will need A LOT of context providers. That will mean a lot of boilerplate code and wrapping of components. 
            Middleware and advanced, context is limited. 
            

    CUSTOM HOOKS
        Regular js function that encompasses and makes use of a hook.

        STRUCTURE
            lib
                hook.js

        EXAMPLE
            export function useItemsContext() {
                const context = useContext(ItemsContext)

                if(!context) {
                    throw new Error
                }
                return context
            }
        BENEFITS
            1 import instead of 2(useContext, itemsContext)
            easier to write useItemsContext() instead of useContext(ItemsContext)
            when using typescript will have to account for situation in which context returns nothing.This logic can be handled here
        
        
    ZUSTAND 
        State management library for react providing simple, lightweight, flexible alternative to redux. 

        BENEFITS
            ease of use
            minimal boilerplate
            powerful capabilities

        WHY IT WORKS WELL
            simplicity
                intuitive and no strict pattern
            performance 
                no unnecessary re-renders
            no context provider hell
                no context api use, so no context provider hell
            versatility
                supports both local and global state management, suitable for different scale applications
            merging of state
                dont have to spread the store object, only the modified part will be changed.
                No need to specify {...store, propToChange: newValue}

        INSTALL 
            npm install zustand

        WHERE
            stores(folder)
                itemsStore.js/ts

        HOW
            Creates a store for managing state. 

            1)store creation
                create function to define state and actions.  

                import create from 'zustand'
            
                const useStore = create((set) => {
                    bears:0,
                    increasePopulation: () => set((state) => ({bears: state.bears + 1})) -> previous State needed, set receives it as parameter
                    removeAllBears: () => set({bears: 0})                                -> no prev state needed, just replace the state.
                    updateBears: (newBears) => set({bears: newBears})                    -> payload from outside needed. Main function receives as param. 
                })
            *)export store
                const export useItemStore = create((set) => ({store}))

            2)accessing the store 
                inside component
                    const bears = useStore((state) => state.bears)
                    const increasePopulation = useStore((state) => state.increasePopulation)

            3)state update
                zustand uses "set" function to update state. 
                Reactive updates: only parts using the affected parts will re render.
            4)middleware support
                supports middleware like extending state or logging changes.
            
        ADVANCED FEATURES
            1)selectors
                derived state
                pick specific parts of the store
            2)middleware
                you can enhance the store with middleware for logging, persistance or async actions.

        WHEN
            small - medium sized applications
            simple alternative to redux
            global state managemnt NO boilerplate
            avoiding limits of context API

        WHERE ZUSTAND SHINES
            NO PROVIDER COMPONENT HELL
            NO UNNECESARY RE RENDER
            NO NEED TO SPREAD STATE, MORE DECLARATIVE PROGRAMMING
            SIMPLE TO SET AND USE
            SMALL,MID,LARGE PROJECTS 
            AVANCED MIDDLEWARE like persist for localstorage
            
TYPESCRIPT IN REACT
    IN COMPONENT PROPS:
        MAINTAINS CONSISTENCY IN PROPS GIVEN AND NEEDED
            Instance
                Given props not defined in component definition will return error.
                    Property 'pillshape' does not exist on type 'IntrinsicAttributes & ButtonProps'
                Missing props defined but not given will remind the user they are needed.
                   Type '{}' is missing the following properties from type 'ButtonProps': backgroundColor, fontSize, pillShapets(2739)

            Definition
                Defined props not used, will return error.
                    'backgroundColor' is defined but never used
            
            INTELLISENSE
                ctrl+space
                    Ts will show all the possible props that the component is expecting

        DEFINING PROP TYPES
            Since prop is an object, prop types will be for objects.

            SYNTAX 1 - INLINE
                export default function Button({backgroundColor,fontSize pillShape}:{backgroundColor:string, fontSize:number, pillShape: boolean}) {
                    return (
                        <button>
                            ...
                        </button>
                    );
                }

            SYNTAX 2 - EXTRACTED PROP TYPE
                Declare type outside of component definition

                type ButtonProps = {backgroundColor:string, fontSize:number, pillShape: boolean}

                export default function Button({backgroundColor,fontSize, pillShape}:ButtonProps) {
                    return (
                        <button className="bg-blue-500 text-white rounded px-4 py-2">
                        Click me
                        </button>
                    );
                }

                EXTRACTED UNION TYPE FOR ALREADY EXTRACTED PROP TYPE
                    type Color = "red" | "blue" | "green"
                    type ButtonProps = {backgroundColor: Color, fontSize:number, pillShape: boolean}


        OPTIONAL PROP 
            type ButtonProps = {backgroundColor:string, fontSize:number, pillShape?: boolean}

        ARRAY TYPE FOR PROP
            type ButtonProps = {backgroundColor: Color[], fontSize:number, pillShape: boolean, padding: number[]}

        TUPLE TYPE FOR PROP
            Will determine:
                1)specific number of elements
                2)type of each specific element

            type ButtonProps = {backgroundColor: Color[], fontSize:number, pillShape: boolean, padding: [number, number, number]}
            <Button padding: [44,33,22]/> -> only 3 elements b/c that is what is defined in the tuple 

        USING AND OBJECT FOR STYLE INSTEAD OF INDIVIDUAL PROPERTIES
            MANUAL 
                type ButtonProps = {
                    style: {
                        backgroundColor: string,
                        fontSize: number
                        etc
                    }
                }

                <Button style={{backgroundColor: "blue", fontSize: 24}}/>
            
            REACT CSS PROPERTIES TYPE
                type ButtonProps = {
                    style: React.CSSProperties
                }

                WHY?
                    Permits use to pass an object filled with actual css properties in the component instance AND AVOID writing all of them in the type created, b/c this is already done by React.
                    Will tell you if you wrote incorrectly a property in the instance, since it will not exist in the interface created by react
                    Will tell you if the value you wrote is incorrect, since it is already defined in he interface what values are permited.

        GENERICS IN PROP TYPES
            type ButtonProps = {
                borderRadius: Record<string, number>
            }

            <Button borderRadius={{
                topLeft: 5,
                topRight: 5, 
                bottomRight:10,
                bottomLeft:10
            }}/>

        TYPES FOR FUNCTION PROPS
            Create and pass the function
                const onClick = (test:string) => 5
                <Button onClick={onClick}/> 

            Specify parameters and their types and return type
                type ButtonProps = {
                    onClick: (test: string) => number
                }

        TYPES FOR CHILDREN PROP
            Giving children to component instance
                <Button>Click me</Button>
            
            Consume prop in component
                export default function Button({children}){
                    ...
                }

            Define in the ButtonProps
                type ButonProps = {
                    children: React.ReactNode 
                }

            FROM REACT
                React.ReactNode
                React.CSSProperties
                React.ReactElement
                React.Dispatch<React.SetStateAction<number>>
                React.MouseEvent<HTMLButtonElement, MouseEvent>
                <HTMLButtonElement>
                REACT.JSX.ELEMENT

            REACT.REACTNODE
                Allows for a range of types that can be rendered by React.
                    string: text content
                    number: numberic contenxt
                    boolean: true or false
                    null: nothing
                    undefined: no content
                    ReactElement: jsx
                    ReactFragment: fragment containing multiple children
                    ReactPortal: portal that renders childen into different parts of the dom
                
        TYPE FOR SET STATE FUNCTION 
            Giving SET FUNCTION to component instance
                <Button setCount={setCount}>Click me</Button>
            
            Consume prop in component
                export default function Button({setCount}){
                    ...
                }

            Define in the ButtonProps
                type ButonProps = {
                    setCount: React.Dispatch<React.SetStateAction<number>>
                }

            React.Dispatch<React.SetStateAction<number>>
                Type of a state setter function returned by useState hook in react.
                Ensures that the setter function can accept either a new state value directly or a function that takes the previous state and returns a new value.

                React.Dispatch
                    dispatch function hat can be used to update state
                React.SetStateAction<number>
                    action that can be dispatched, either new state value number or function with prev state returning new type of number.
            
        ComponentProps<"element"> 
            This line means that ButtonProps will inherit all the props of a native HTML <button> element.

            ComponentProps: 
                This utility type extracts the props of a given React component or an HTML intrinsic element (like "button", "div", etc.).

            <"button">: 
                This specifies which component or HTML element you want to extract props from. In this case, it's the intrinsic "button" element.

            HOW
                HTML elements in React, such as <button>, have predefined props, like onClick, disabled, and so on.
                ComponentProps<"button"> automatically generates the type definition for these props, so you don't need to manually define them. 
                
            EXAMPLE
                type ButtonProps = ComponentProps<'button'>

                ONLY SPEAD(...PROPS)
                    const Button: React.FC<ButtonProps> = (props) => {
                        return <button {...props}>{props.children}</button>    
                    }

                REST OP(...REST)
                const Button: React.FC<ButtonProps> = ({type, autoFocus, ...rest}) => {
                    return <button type={type}, autoFocus={autoFocus}, {...rest}>{props.children}</button>    
                }
                
                <Button type="submit" autoFocus={true} defaultValue="test"/>

            HELPER(UTILITY) TYPES
                Predefined types that simplify common type manipulation.
                
                Syntax for Helper Types:
                    Helper types typically use generics. For example:
                        type MyType<T> = Partial<T>;

                COMMONLY USED 
                    Partial<T>: Makes all properties of a type optional.
                        type Person = { name: string; age: number };
                        type OptionalPerson = Partial<Person>;
                        // { name?: string; age?: number }
                    Required<T>: Makes all properties of a type required.
                        type OptionalPerson = { name?: string; age?: number };
                        type FullPerson = Required<OptionalPerson>;
                        // { name: string; age: number }
                    Readonly<T>: Makes all properties read-only.
                        type Person = { name: string; age: number };
                        type ReadonlyPerson = Readonly<Person>;
                        // { readonly name: string; readonly age: number }
                    Pick<T, K>: Picks specific keys from a type.
                        type Person = { name: string; age: number; location: string };
                        type NameAndAge = Pick<Person, "name" | "age">;
                        // { name: string; age: number }
                    Omit<T, K>: Excludes specific keys from a type.
                        type Person = { name: string; age: number; location: string };
                        type WithoutLocation = Omit<Person, "location">;
                        // { name: string; age: number }
                    Record<K, T>: Creates a type with keys K and values of type T.
                        type RolePermissions = Record<"admin" | "editor" | "viewer", boolean>;
                        // { admin: boolean; editor: boolean; viewer: boolean }
                
        INTERSECTION 
            Way to combine multiple types into a single type including all properties and methods of each constituent type. (&)

            EXAMPLE
                Situation to determine the props for a regular element and then inrtersect with something extra for another element.

                type = ButtonProps = {
                    type: "button" | "submit" | "reset",
                    color: "red" | "blue" | "green"
                }
                type SuperButtonProps = ButtonProps & {
                    size: "md" | "lg"
                }

            EXAMPLE FOR INTERFACE
                type SuperButtonProps extends ButtonProps {
                    size: "md" | "lg"
                }

    IN EVENT HANDLERS
        INLINE
            Ts can infer the type of the parameters of inline handlers.

            EXAMPLE
            <button onClick = (e) => console.log("clicked")> 
            TYPE: event: React.MouseEvent<HTMLButtonElement, MouseEvent>

        EXTRACTED
            No longer infered, must define manual.

            const handleClick = (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => console.log("clicked")

    WITH STATE
        Ts can infer the type with the default value. 
        Manual definition of type can also be done.

        EXAMPLE
            useState<number>(3)

        WITH NULL INITIATION
            1)Make sure the type is defined and unioned with null
                type User = {
                    name:string
                }
                const [user, setUser] = useState<User | null>(null)
            
            2)Guard clause for when the state is actually null
                const name = user?.name

    WITH USEREF
        const ref = useRef<HTMLButtonElement>(null)
    
    AS CONST
        Makes an inferred type a literal typ
        Makes the type a readonly

    ASSERT
        Explicitly giving a type to something ts has inferred.

        type ButtonColor = "red" | "blue" | "green"

        useEffect(() => {
            const previousButtonColor = localStorage.getItem("buttonColor") as ButtonColor
        }, [])

    GENERICS
        With react, must have a comma after defining the generic type. 
            <T,> this is so ts does not confuse this with an html element

        INLINE
            function ConvertToArray <T> (contValue: T): T[] {  
                ...              
                }
        EXTRACTED
            type ButtonProps<T> = {
                countValue:T,
                countHistory: T[]    
            }
            export default function Button<T>({countValue, countHistory}: ButtonProps<T>)

    EXPORT AND IMPORT
        EXPORT
            LIB folder  
                types.ts 
                    export type Color = "red" | "green" | "blue"

        IMPORT 
            import {type Color} from "@/lib/types"
            

    UNKNOWN
        Some situations where data is unknown, ts will default to any(e.g. Fetching from an API)

        .then((response) => response.json())
        .then((data:unknown) => console.log(data))

        ZOD
            Following the example above, we can parse the data through zod to ensure it will be the particular form we thought it would be. 
            
    IN COMPONENT RETURN TYPE
        Ts can infer the return type of a react element.
            REACT.JSX.ELEMENT | JSX.ELEMENT 

    WHERE TO REACT TYPES COME FROM 
        React.ReactNode
        React.CSSProperties

        Nodemodules and that gets them from the repo definitely typed

    TSCONFIG.JSON
        
        
    ZOD
        Validator of types and parser

    TS-RESET
        
    
PROJECT 4 - CORPCOMMENT
    WHAT
        write comment about something 
        # to categorize the comment
        # of characters limit
        filter by #
        Upvoting
        Persisting data to server
        get - post data 

    TOOLS
        TS
        CONTEXT
        ZUSTAND

    VITE WITH TS FRESH LOOKAROUND
        npm create vite@4.4.1 . 

    .d.ts files
        Declaration files that make declarations available

    RADIX ICONS
        npm install @radix-ui/react-icons@1.3.0

    TS in state
        Infers based on the initialValue

        INFERED TYPE NEVER BASED ON EMPTY INITIAL STATE
            Type 'TFeedbackItem' is not assignable to type 'never'.ts(2322)

            PROBLEM
                const [feedbackItems, setFeedbackItems] = useState([]);

            ANSWER
                const [feedbackItems, setFeedbackItems] = useState<TFeedbackItem[]>([]);

                

    TS IN e param of handler function
        EXTRACTED
            e: React.ChangeEvent<HTMLTextAreaElement>

        INLINE
            <textarea onChange((e) => ...)>...</textarea> -> ts can recognize it is a change event on a text area element.

    EXPLICIT RETURN ON MAP
        blabla.map((item) => ({ ->allows to return object or component without writing the word
        }))

    TS IN PROPS
        Takes care of you
            intellisense
            no grammar mistakes
        
    LOADINGSTATE
        isLoading state
        conditionally render spinner

    Ts in data methods
        Depending on the data type method, ts could return undefined. In this cases we need to narrow it down and add guard clasuses so ts knows the undefined case has been handled. 

    OPTIMISITC POSTING AND RENDER
        update ui first
        post data to server second

    COMPONENT STRUCTURE
        create folders to improve the folder structure of the app 
            src
                app.tsx
                layout  
                    header.tsx
                    container.tsx
                    footer.tsx
                feedback
                    all items related to this
                ...rest
    
    indexOf() method
        find position of first ocurrence of specific value in an array. 
        
        SYNTAX
            array.indexOf(element, start[opt])

        RETURN
            index of first ocurrence
            -1 if not found

        EXAMPLE
            How to remove duplicate items from the company list array 
              const companyList = feedbackItems
                .map((item) => item.company)
                .filter((company, index, array) => array.indexOf(company) === index); //more derived state

    HASHTAG FEATURE
        hashtag list
            hastag item
                company name from feedback items
                removed duplicate
                inserted hasthtag
        filter by hashtag item
            create selectedCompany state
            add condition to filter feedbacklist items based on this state
            setSelectedFilter function on an onClick button event of the hashtag list items 
                create function and pass it down from app -> #list -> #item 

    ? OP WITH FILTERING A STATE
        selectedFilter state ? filter the list : original list 

    USEMEMO(memory efficient hook)
        Avoid computation by storing calculations in memory
    
        usual dependencies(states used inside determine the dependencies) 
            1)state worked on
            2)state that can change item 1

    Toggle feedback item
        state to control toggle
        conditionally style based on state
        change state with event handler

    Upvote feature
        upvotelocalstate and setstate(initialize with upvote )
        onClick event handler -> setstate
        e.stopPropagation()
        limit upvote
            
    validation when user submits form 
        conditionally render styles on form depending on both states
            green - correct format (conditions for valid)
                state for valid
                setstate true
                setTimeout - to turn off state
            
            red - incorrect format
                state for invalid
                setstate true
                setTimeout - to turn off state
                return - we don't want the rest of code to execute

    CUSTOM HOOK FOR CONTEXT
        1)encapsulates the validation logic 
        2)allows the validation logic to be reused
        3)once we get context, we avoid initial null value scenario 

    DOWNFALL OF CONTEXT
        If even 1 thing in the values object changes, the whole lot of components will have to re render. 
        
    CREATION OF CUSTOM HOOK FOR DATA FETCHING
         
    
P5 - RMTDEV
--------------
TO LEARN(NEW TOPICS)
    1)React Query 
    2)Cache
    3)Debounce

FEATURES(SECTIONS)
    1)Search jobs
    2)Job List
    3)Job Details
    4)Pagination
    5)Sorting
    6)Bookmarks
    7)Performance

INITIALIZE PROJECT
    CLONE REPO  
        git clone https://github.com/ByteGrad/starter-rmtdev.git .

        NO .
            Creates folder with repo name.

        WITH .
            Unloads the files of the repo in the folder we are located in the terminal.

1.1)SEARCH
    Search Component(Controlled Input)
        OnSubmit Handler
            Create handleSubmit function
            e.preventDefault
            e: React.FormEvent<HtmlFormElement>
        searchText state
            const [searchText, setSearchText] = useState<string>("")
        onChange function
            e: React.ChangeEvent<HtmlInputElement>
            setSearchText(e.target.value)
        Input Element
            value={searchText}
    Fetch jobItems on search
        REQUIREMENT
            Should fetch every time the input detects a change, NOT depending if state changes
        WHERE
            useEffect
                Guard Clause
                    !searchText return -> avoid fetching on an empty state in the initial render
                Dependency
                    searchText -> Fetches on the re render caused by the state change with the most recent value
        ANATOMY
            fetchJobItems async function
                !res.ok
                    Throw Error
              setJobItems state to data.jobItems from fetch
1.2)Showing jobItems(search results)
        List state up
            Move searchText & jobItems to App
        Render jobItems
            Prop Drill
                App -> Container -> Sidebar -> jobLst
            jobList
                map jobList and return a <jobListItem/> for every item
            jobListItem
                render jobItem info
    Typing 
        jobItem and jobListItem
    Prevent Prop Drilling
        Children Pattern
            Typing all components using children
                children: React.ReactNode
    Loading 
        State
            const [isLoading, setIsLoading] = useState(false)
        WHERE 
            Before fetch
                true
            After success fetch
                false
        CONDITIONALLY RENDER SPINNER
            {isLoading && <Spinner/>}    -> Only shows spinner if it is loading
            {!isLoading && jobItems.map  -> Only shows ListItems if fetch is no longer fetching
    Type
        JobItem
            exported to types file
        JobList
            Jobitems: JobItem []
            isLoading: boolean
        JobListItem
            jobItem: JobItem
    useJobItems custom Hook
        Objective
            Group all logic related to this feature in a single place
        Benefit
            1)De clutter main app or files unnecessary for this
            2)If implementation wants to be changed, only 1 place to work on
                useEffect
                React-Query
                Other libraries
            3)Re use logic
    Slice jobItems into a Page
        jobItems.slice(0,7)

        WHERE
            useJobItems custom hook
    JobItems to Tuple
        WHY
            Where prop is sent
                Receives type as union number | string
            Where prop is used
                Props is defined as what it should be ideally
        PROB
            Both come into conflict and must be addressed
        SOLU
            Tuple will provide ideal type for each
                return [jobItemsSliced,isLoading] as const
    Key Prop
        Funny enough, it must be given but react won't pass it. 
        It won't be received on the component definition side. 
    Type Form
        searchText: string
        setSearchText: React.Dispatch<React.SetStateFunction<string>>.
2)JOB DETAILS
    Keep track of active job Id
        WHY 
            1)style based on active job
            2)share current id for page to load in that state
        URL HASH
            fulfills requirements to share and load.
            state will lose its value on initial load.

            WRITING
                <a href={`#${jobItem.id}`}
                HOW
                    Window.location.href gets or sets the url.
                    Anchor tags href prop has access to the window.location.href   
            READING
                Tap into hashchange event with an event listener.
                WHERE
                    UseEffect
                HOW
                    window.addEventListener("hashchange", () => {...})
        Initially call to handlehaschange
            if there is something in the hash
            useEffect runs the function without need for hashchange event

            PRO
                Avoids need to set initial value | null in state


        STATE
            const [activeId, setActiveId] = useState<number | null>(null) 
            WHERE
                app, b/c jobList and jobItemContent need it
            WHY
                Hash alone won't cause re renders, it is for data persistance only.
            
    useActiveId custom Hook
        Objective
            Group all logic related to this feature in a single place
        Benefit
            1)De clutter main app or files unnecessary for this
            2)If implementation wants to be changed, only 1 place to work on
    Fetch jobItemContent(Custom Hook)
        WHEN 
            activeId changes
        REMEMBER
            onClick for specific jobItem already deals with changing the hash and the activeId state. We can work with reacting to this change. 
        guardClause
            !activeId return
        Types consistency is enforced
            A type defined before (activeID = number | null) will force you to keep that same type and work around it.

            EXAMPLE
                useJobItemContent(activeId: number | null)
                    type narrow the null case with guard clasue
                    only number type is left to deal with
    type JobItemContent
        perfect example of type intersection
            export type JobItemContent = JobItem & {
            ... extra
        }
        Initial type for JobItemContet useState
            JobItemContent | null
            WHY
                When initialized, there is a scenario in which the fetch is not run b/c activId is not there and has not changed. 
                    In this situation we work with null.

            Guard clause
                Rememember to always guard clause a null state
            Prop does not exist on type never Error
                Error message when state is initialized empty and is not unioned with the actual type
        Importing same name type as component
            import {type JobItemContent}
    Render JobItemContent
        Render EmptyJobContent
            if !JobItemContent return <EmptyJobContent/>
    isLoading
        Multiple isLoading must be in separate files. 
    Style active jobListItem
        inside jobListItem
            useActiveId c-hook
            isActive={activdeId == jobItem.id} -> conditionally render prop to produce boolean value
    ResultsCount
        derived state in useJobItems hook where info is readily available
3)Debounce searchText
    Obj
        Limit api fetch until user has finished typing in input
    HOW
        Fetch with a debounced searchText
    
    STEPS
        useEffect(() => {
            const timerId = setTimeout(() => setDebouncedSearchText(searchText), 1000)
            return () => clearTimeout(timerId)
        },[searchText])
    type with generics
        useDebounce<T>(value:T,delay = 1000):T
    Default params
        Perfect use for a standard delay unless user specifies.
4)Changing fetch to React-Query
    Obj
       Store recently fetched data to avoid re fetching
    WHERE
        1)jobItems
        2)jobItemContent
    PROVIDER
        Establish a provider in the main file with <App>
    FETCHER FUNCTION
        Extracted named function 
    type assertion for null case of a type 
        Good way to deal with the datatype | null guard clause
    typing data from react query
        SOLU
            type data returned from fetcher function
    typing fetch function 
        Promise<JobItemContent>
    Error handling
        Pass the error
        Use the error
            onError: (error) => {
                console.log(error)
            } 
    Purify the function
        Remove derived states to maintain the function pure
    Refactor the useJobItems Hook
        Possibility of undefined
            If funcion is never run, the returned data could be undefined. 
            SOLUTION
                Just like before, give it an initial value.
            EXAMPLE
                initialData: [], // Ensures data starts as an empty array
            WHAT HAPPENS
                Data will never be undefined, always empty array or full array
        Possibility of undefined values that are being sent with one data type | undefined and where they are used they are defined as without undefined.
            Short circuit the negative case scenario
                const jobItemsSliced = jobItems?.slice(0 ,ITEMS_PER_PAGE) || []
                 const jobItemsCount = jobItems?.length || 0
4)Add toast messages
    Use library
        <Toaster position="top-right"/>
        toast.error={message}
    Type narrow the message passed to toast for ts
        WHY
            React query error param is unknown type. Ts hates this.
        HOW
            let message 
            if(error instanceof Error){
            message = error.message
            }
            else if(typeof error === "string"){
            message = error
            }
            else{
            message = 'An error occured.'
            }
            toast.error(message)
        THINK OF IT THIS WAY
            ts needs proof what you are doing is allowed and you must proof it is of that type for him to allow it.
    Create error util function 
        For reusability purposes move the entire function to the utils and import in the hook.
5)Pagination
    Set the components
        import the radix arrow components
    State to store page
        const [currentPage, setCurrentPage] = useState(1)
        WHERE
            App b/c jobItem to slice by page is there already.
    Create previous and next page functions for the buttons
        const handleChangePage = (pagination: 'previous' | 'next') => {
            if(pagination === 'previous'){
            setCurrentPage((prev) => prev - 1 )
            }
            else if(pagination === 'next'){
            setCurrentPage((prev) => prev + 1)
        }
        WHY
            specific due to error in providing the parameter
    render previous and next page in buttons
        send currentPage as prop to paginationControls
        {currentPage -1}{currentPage +1}
    conditionally render previos and next buttons
        previous
            {currentPage > 1 && previousButton}
        next
            derive last page
                const lastPage = jobItemsCount / ITEMS_PER_PAGE

            {currentPage < lastPAge && nextButton}
    create custom paginationButton component
        conditionslly render page and arrow based on direction 
            {direction === "previous" && (
                <>
                Page {page - 1}
                <ArrowLeftIcon />
                </>
            )}
        conditionally style the class for the next button only
            className={`pagination__button ${
                direction == "next" ? "pagination__button--next" : ""
            }`}
        type using almost same types and invoke the function 
    derived pagination state
        const lastPage = jobItemsCount / ITEMS_PER_PAGE;
    use pages to determine the slice of jobitems to render
        const jobItemsSliced =
            jobItems?.slice(
            currentPage * ITEMS_PER_PAGE - ITEMS_PER_PAGE,
            currentPage * ITEMS_PER_PAGE
        ) || [];
6)Sorting
    By:
        1)recent | daysAgo
        2)relevance | relevanceScore
    STATE
        const [sortBy, setSortBy] = useState<'relevant' | 'recent'>('relevant')
    WHERE
        App b/c it will be used to sort jobItems
    ORDER
        1)fetch
        2)sort
        3)paginate
    handleSortBy function
        const handleSortBy = (sortOption: 'relevant' | 'recent') => {
            setSortBy(sortOption)
        }
        back to first page
            setCurrentPage(1)
    style active sort option class
        sortOption === 'recent' | 'relevant' ? sorting__button--active : ""
    sort jobList based on sortBy
        [...(jobItems|[])].sort()
            To work on a brand new array and not modify the existing.
        a - b
            less to more
        b - a 
            more to less
        always specify default return like in switches
            return 0 in this case
        guard clause
            if jobItems is undefined || []
    render based on jobItemsSorted
        jobItemsSorted?.slice(pages)
    create & use SortBy & Direction types
        import { Direction, SortBy } from "../lib/types";
        export type SortBy = 'relevant' | 'recent'
        export type Direction = "previous" | "next"
    
7)Bookmarking
    WHAT
        Keep log of bookmarked jobs
    WHERE
        LocalStorage
    BookmarkIcon
        create state to store bookmarkedIcons
            const [bookmarkedIds, setBookmarkedIds] = useState<number>([])
        create handle toggleBookmarks
            if !bookmarkedIds.includes(id)
                add it 
            else
                remove it
        Context API
            WHY
                1)used in jobListItem & JobItemContent
                2)too many levels too drill app -> list -> item -> bookmarkIcon

            create context
                const BookmarkContext = createContext<BookmarkContextProps | null>(null);
                    1)bookarmedIds state
                    2)handleToogleBookmarks
            wrap context around app
                ReactDOM.createRoot(document.getElementById("root")!).render(
                    <React.StrictMode>
                        <QueryClientProvider client={queryClient}>
                            <BookmarkContexProvider>
                                <App />
                            </BookmarkContexProvider>
                        </QueryClientProvider>
                    </React.StrictMode>
                );

            type context & context provider
                type BookmarkContextProps = {
                    bookmarkedIds: number[]
                    handleToggleBookmark: (id:number) => void
                }
                type BookmarkContextProviderProps = {
                children: React.ReactNode
                }
            create custom hook for useBookmarkedIdsContext
                export const useBookmarkedIdsContext = () => {
                const context = useContext(BookmarkContext)
                if (!context) {
                    throw new Error(
                    "BookmarkedIds context needs to be used inside the provider"
                    );
                }
                return context;
                }
            consume context in jobListItem & JobItemContent
                const {bookmarkedIds, handleToggleBookmark} = useBookmarkedIdsContext()
        Send id to bookmark icon
            jobListItem
                <BookmarkIcon jobItemId={jobItem.id}/>
            jobItemContent
                <BookmarkIcon jobItemId={jobItemContent.id}/>
        Use toggler
            <button className="bookmark-btn" onClick={() => handleToggleBookmark(jobItemId)}>
        Conditionally stle filled class
            <BookmarkFilledIcon className={bookmarkedIds.includes(jobItemId) ? "filled" : ""}/>
        StopPropatation and preventDefault
            Anchor default behavior will always be to go to specific place.
            e.stopPropagation()
            e.preventDefault()
        Local Storage
            Write
                useEffect
                    b/c it is an exeternal system
                  useEffect(() => {
                    localStorage.setItem('bookmarkedIds', JSON.stringify(bookmarkedIds))
                }, [bookmarkedIds])
            Read
                1)read from LS
                    const bookmarksFromLocalStorage = JSON.parse(localStorage.getItem("bookmarkedIds") || "[]")
                WHY
                    structure of array needs to be in string before converted
                2)set initial state to the search from LS
                      const [bookmarkedIds, setBookmarkedIds] = useState<number[]>(bookmarksFromLocalStorage);
                3)change initial state to function to avoid on every re render
                    const [bookmarkedIds, setBookmarkedIds] = useState<number[]>(() => JSON.parse(localStorage.getItem("bookmarkedIds") || "[]"));
        use LS custom hook 
            purpose
                1)Persist any data not only the bookmarks
                2)De clutter main app and enmcapsulate logic for reusability
            Implementation
                1)create state and initialize if reading from LS
                2)write with it on a useEffect to LS
                3)return state and setState functions
            type custom hook with generics
                export function useLocalStorage<T>(key:string, initialValue:T):[T, React.Dispatch<React.SetStateAction<T>>] 
                    ...
                }
        
    BookmarkButton && BookmarkPopup
        Obj
            fetch full data of job based on ids of bookmarkedIds in LS

        State controlling
            const [isOpen, setIsOpen] = useState(false)
        Function toggling     
            const togglePopOver = () => {
                setIsOpen((prev) => !prev)
            }
        Conditionally rendering
            Anywhere b/c of its CSS
            {isOpen && <BookmarksPopover/>}
        Render jobList inside bookmarks popover
            <JobList jobItems={[]} isLoading={false}/>
        rename useJobItems to useSearchQuery
            Appropriate name for the function.
            UseJobItems should be the plural of useJobItemContent and work with Ids.
        create useJobItems hook to fetch multiple jobItems based on Id
            export function useJobItems(ids: number[]){
                const jobItems = useQueries({
                    queries: ids.map((id) => ({
                    queryKey: ["job-item", id],
                    queryFn: () => fetchJobItemContent(id),
                    staleTime: 1000 * 60 * 60,
                    refetchOnWindowFocus: false,
                    retry: false,
                    enabled: !!id,//on mount condition to run, if id run.
                    onError: handleUnknownError // auto passed parameter
                    })),
                })
                console.log(jobItems)
                return jobItems
            }
        Transform the result and filter out the undefined
            const jobItems = results.map((result) => result.data).filter((jobItem) => jobItem !== undefined)
        Add to context Type 
            bookmarkedJobItems: JobItemContent[]
        Create global isLoading based on individuals isLoading
              const isLoading = results.some((result) => result.isLoading)
        IN bookmarks context, use the hook with the already saved bookmarkedIds array
            const [bookmarkedJobItems, isLoading] = useJobItems(bookmarkedIds);
        Add these bookmarkedJobITems to the context to be distributed
            value={{
                bookmarkedIds, handleToggleBookmark,bookmarkedJobItems,isLoading
            }}>
        Use This newly shared bookmarkedJobItems in the BookmarkPopover
            
       LAST  modify bookmarks context to useJobItems with bookmarksId
            const {jobItems, isLoading} = useJobItems(bookmarkedIds)

         LAST consume the bookmarks context to retrieve bookmarkedIds
            const {jobItems, isLoading} = useBookmarkedIdsContext()

        Close popover on clicking outside
            Obj
                Clicking outside the popover will close it
            HOW
                Use popover as basis and whenever you click outside it, make it close.
            1)e.target.closest('.class')
                useEffect()
                    const handleClick = (e) => {
                        if (
                            e.target instanceOf HTMLElement && 
                            !e.target.closest(".bookmarks-btn") &&
                            !e.target.closest(".bookmarks-popover")
                        )
                            setIsOpen(false);
                        };
                        document.addEventListener("click", handleClick);

                        return () => {
                        document.removeEventListener("click", handleClick);
                    };
                DOWNSIDE
                    Too dependent on classes, if they change everything changes.
            2)useRef()
                create refs
                    const buttonRef = useRef<HTMLButtonElement>(null)
                    const popoverRef = useRef<HTMLDivElement>(null)
                use refs in conditionals
                    if (
                        e.target instanceof HTMLElement && 
                        !buttonRef.current?.contains(e.target) &&
                        !popoverRef.current?.contains(e.target)
                    )
                provide refs to elements
                    <button ref={buttonRef}>
                    <BookmarksPopover ref={popoverRef}/>
                consume ref on the bookmarks popover
                    const BookmarksPopover = forwardRef(function(props, ref) {
                    return <div ref={ref} </div>;
                    })
                    export default BookmarksPopover
                type the ref
                    as usual generics in the function provided by react

                    forwardRef<HTMLDivElement>
                how would you type the props
                    forwardRef<HTMLDivElement, {here}
                irony
                    typing
                        ref = 1 
                        props = 2
                    function parameters
                        props = 1
                        ref =2 
                custom hook 
                    What do we need to pass?
                        1)refs in []
                        2)function to execute
                    Iterate over refs and make 1 functin to execute for all
                        refs.every((ref) => !ref.current?.contains(e.target))
                Final Product
                    export function useClickOutside(refs, handler) {
                        useEffect(() => {
                            const handleClick = (e: MouseEvent) => {
                            if (
                                e.target instanceof HTMLElement && 
                                refs.every((ref) => !ref.current?.contains(e.target))
                            )
                                handler()
                            };
                            document.addEventListener("click", handleClick);

                            return () => {
                            document.removeEventListener("click", handleClick);
                            };
                        }, [refs, handler]);
                    }
                Type the refs and the handler
                    Typing
                        refs:React.RefObject<HTMLElement>[], handler: () => void
                    Asserting
                        e.target as Node
                    
8)Performance optimizations
    1)useActiveID
        PROBLEM
            Whenever it is used, all code will run again. 
                1)useeffect will run
                2)usestate will be created several times
                3)eventlisteners will be created several times
            Currently used in 2 places:
                1)JobItemContent(to indicate which jobItem to fetch)
                2)JobItemList(indicate which item to highlight as active)
        SOLUTION 
            Context it so only 1 exists and can be shared.
        PROCESS
            create ActiveIdContextProvider component
                1)export const ActiveIdContext = createContext<ActiveIdContext | null>(null);
                2)export default function ActiveIdContextProvider({children}: ActiveIdContextProviderProps) {
                    const activeId = useActiveId();
                    return <ActiveIdContext.Provider value={{activeId}}>
                        {children}
                    </ActiveIdContext.Provider>;
                }
            create useActiveIdContext Hook for boilerplate guard clause code
                export const useActiveIdContext = () => {
                const context = useContext(ActiveIdContext)

                if (!context) {
                    throw new Error(
                    "useActiveIdContext needs to be used inside the provider"
                    );
                }
                return context;
                }
            wrap around app
                This is where the context provider hell comes from
                    <React.StrictMode>
                        <QueryClientProvider client={queryClient}>
                            <ActiveIdContextProvider>
                                <BookmarkContexProvider>
                                    <App />
                                </BookmarkContexProvider>
                            </ActiveIdContextProvider>
                        </QueryClientProvider>
                    </React.StrictMode>
            consume
                const {activeId} = useActiveIdContext()
                    1)JobItemContent    
                    2)JobList
        RESULT
            State is created only once
            Event listeners are attached only one
            Data is maintained pure and shared
        
    2)Pulling everything from the App component(context everything)
        PROBLEM
            state will cause anything in that component and its children to re render. (Basically all the app)
        LESSON
            Try the most you can to avoid re calculating array calculations.(very expensive)
        A)Search Text
            a)create searchTextContextProvider component
                1)move searchText and debouncedSearchText to here
                2)provide value={{searchText, debouncedSearchText, setSearchText}}
            b)create useSearchTextContext
                useContext(searchTextContext)
            c)consume useSearchTextContext everywhere we need 
                1)jobItems requres debouncedSearchText, we can't put it in app must create context
                2)form(provides searchText, setSearchText)
        B)JobItems
            a)create JobItemsContexyProvier
                1)move jobitems, sortby, currentPage
                2)provide all of it
            b)create usejobitemscontext
                useContext(jobItemsContext)
            c)consume useJobItemsContext
                1)jobList
                2)paginationControl
                3)sortingControl
                4)ResultsCounter
            d)Special case due to giving it different information
                BEFORE
                    a)app
                        We were giving it the whole joblistitemsliced
                    b)boomkarkpopover
                        We were giving it the whole bookmarkedJobItems
                NOW
                    a)App
                        <JobListSearch/>
                            Data
                                const {isLoading, jobItemsSliced} = useJobItemsContext()
                            Render
                                <JobList jobItems={jobItemsSliced} isLoading={isLoading} />
                    b)BookmarkPopover
                        Data
                            const { bookmarkedJobItems, isLoading } = useBookmarkedIdsContext();
                        Render
                            <JobList jobItems={bookmarkedJobItems} isLoading={isLoading} />
    3)useMemo(Memoize derived state)
        Efficiency in 2 steps = avoiding unnecessary
            1)re - renders
                Already worked on by encapsulating and contexting everything.
            2)computations
                There could still be some things that even if the component re renders, complete recalculation may not be necessary.
        1)Sorted case
            PROBLEM
                Since everything is in context, sorted calculation may run if page state changes and it     
            shouldn't b/c sort runs before slicing. Page changes but the items are already correctly sorted.

            SOLUTION
                Memoize unless JobItems or sortby change. No need to re run if page changes.
        2)Splice case
            PROBLEM
                None really, no case exists where this is not necessary to re run but oh well
            SOLUTION
                Memoize LOL
        3)Context Value case
            PROBLEM
                when state in context changes, return value is recalculated and all consumers re render entirely independent of what value changed b/c it recalculates all of it.
        4)Callbacking functions
            PROBLEM
                function gets re created on every render with new reference in memory, meaning the memo will detect it as a new changed one and re calculate everything. It defeats the purpose of the memo, having functions not callbacked.
            SOLUTION
                useCallback(useMemo but for functions)
                
NEW TOOLS
    React Query
        Powerful library to manage state and fetching.

        WHY
            Automaically handles all the manual things you are used to doing:
                1)loading 
                2)errors
                3)caching
                4)refetching stale info
        COMPARISON
            WITHOUT
                useEffect -> fetch
                useState -> result
                useState -> loading
                useState -> errors
                manual re fetch for stale info
            WITH
                useQuery hook
        INSTALL
            npm install @tanstack/react-query
        SETUP QUERY CLIENT IN MAIN FILE
            import {QueryClient, QueryClientProvider} from "@tanstack/react-query"

            const queryClient = new QueryClient()

            function App() {
                return(
                    <QueryClientProvider client={QueryClient}>
                        <...>
                    </QueryClientProvider>
                )
            }
            WHAT HAPPENS
                Query client wraps around your app and enables caching for all app.
        FETCH DATA WITH USEQUERY
            import {useQuery} from "@tanstack/react-query"

            function MyComponent() {
                const {data,error,isLoading} = useQuery({
                    queryKey: ['key'], 
                    queryFn: async () => {
                        const response = await fetch("https://your-api.com/data");
                        if (!response.ok) {
                        throw new Error("Network response was not ok");
                    }   
                        return response.json(); // Return the parsed JSON data
                    },
                    staleTime: 1000 * 60 * 5, 
                    cacheTime: 1000 * 60 * 10,
                    refetchOnWindowFocus: false, // 
                })
            }
            PARAMS
                queryKey                -> unique key to remember query for caching
                queryFn                 -> fn that fetches
                isLoading               -> true while fetching
                error                   -> request fails(500)
                data ->                 -> data response
                staleTime               -> (Optional) Keep data fresh
                cacheTime               -> (Optional) Keep data in cache
                refetchOnWindowFocus    -> (Optional) Prevent refetching when window regains focus
                enabled                 -> (optional) Run on mount? (boolean)
                onError                 -> func to run when error occurs 
            RETURNED
                Property	Type	        Description
                data	    Object / Array	The response data from the API.
                error	    Object / null	The error object if the request fails.
                isLoading	Boolean	        true while the query is fetching for the first time.
                isError	    Boolean	        true if an error occurred.
                isFetching	Boolean	        true if React Query is refetching data in the background.
                refetch	    Function	    A function to manually trigger a refetch.
        IMPROVEMENTS
            1)No more manual state handling(isLoading, Error, Data)
            2)Cache
            3)auto updates stale data
            4)No need for custom try catch
        DIFF isLoading vs isInitialLoading
            isLoading: 
                true when the query has no cached data and is fetching.
                This means while we haven't fetched, it is true and spinner forever.
            isInitialLoading: 
                true only while fetching and then false forever.
            RESULT
                If the query refetches (e.g., due to enabled changing or a manual refetch), isLoading might be true again, but isInitialLoading will remain false.
        INITIAL RETURNED DATA BEFORE FETCH
            React query does not know what to return, so it returns UNDEFINED.
        PLACEHOLDERDATA
            it gives React Query a temporary value (in this case, an empty array []) while the actual data is being fetched. 
            LIKE SAYING
                NOW - assume an empty array
                LATER - i'll change it after the fetch is done
            BENEFITS
                No dealing with undefined
        USEQUERIES
            Way to make several fetches in paralell instead of waterfall
            Each querie has its individual data,loading,error.

            SYNTAX
                const jobItems = useQueries({
                    queries: ids.map((id) => ({
                    queryKey: ["job-item", id],
                    queryFn: () => fetchJobItemContent(id),
                    staleTime: 1000 * 60 * 60,
                    refetchOnWindowFocus: false,
                    retry: false,
                    enabled: !!id,//on mount condition to run, if id run.
                    onError: handleUnknownError // auto passed parameter
                    })),
                })
                console.log(jobItems)
                return jobItems
        
        
    REACT HOT TOAST
        Customizable react library for toast notifications.

        FEATURES
            lightweight and fast
            auto dismissable
            customizable
            promise support
            works anywhere
            
        INSTALL
            npm install react-hot-toast
        USAGE
            import { Toaster, toast } from 'react-hot-toast';

            function App() {
                return (
                    <div>
                    <button onClick={() => toast('Hello, world!')}>Show Toast</button>
                    <Toaster />
                    </div>
                );
            }
            export default App;
        TYPES
            1)toast.success('Successfully saved!');
            2)toast.error('Something went wrong!');
            3)Custom Toast with Loading Indicator
                toast.promise(myPromise, {
                    loading: 'Loading...',
                    success: 'Data loaded!',
                    error: 'Error loading data!',
                });
            4)Custom Styling
                toast('This is a custom toast', {
                    duration: 4000,
                    position: 'top-right',
                    style: {
                        background: '#333',
                        color: '#fff',
                    },
                });

    createPortal()
        createPortal lets you render some children into a different part of the DOM.

        SYNTAX
            {createPortal(children, domNode, key?)}
        
        WHERE DOES IT END UP
            Literally outside the .root
        
LEARNED - SUMMARY
    cacheing
        storing frequently accessed data in a temp storage location to reduce retrieval time and improve performance. 
        POPULAR WAYS
            1)react-query
            2)nextjs
            3)swr vercel
    clone repo to here
        git clone https://github.com/ByteGrad/starter-rmtdev.git .
    sharing repo    
        package.json to install node_modules and avoid uploading the massive folder 
    icon to use action
        wrap icon in a button 
            example
                BookmarkIcon
                BookmarkButton
    reusability even in small components
        BookmarkIcon component 
    logo to start page
        wrap image or icon in anchor tag 
        Children prop to encapsulate html tags
    create component that will use a div to wrap around children. This encapsulates logic.
        EXAMPLE
            export function SidebarTop({children}: {children: React.ReactNode}){
                return (
                    <div className="sidebar__top">
                    {children}
                    </div>
                )
            }
    FETCHING BASED ON PURPOSE
        onLoad
            state changes and causes:
                1)component re renders
                2)new state value is given as input value
                3)new state value is used in the UI
                3)useEffect runs again and fetches based on most recent state value(last to happen)
        onReaction
            onChange(equivalent event)
    Params
        Query
            resource located, need to filter further
            example
                search
                sortBy
                limit
        Path(Route)
            locate specific resoure
    Never Type(cause by [])
        Ts type that represents a value that never occurs. 
        Expression will never produce a value.
        Ts will infer this value when initializing an empty array [].
    Loading state
        Must use 2 conditionals
        1)isLoading && <Spinner/>
            Always needed
        2)!isLoading && Data.map
            WHY?
                If is loading, then spinner AND data will map. Prevents niche cases of previous fetch data existing and new fetch being loaded.
    How custom hooks work
        HOW
            By following proper hook logic, we guarantee it will work as if it is not there
        Objective
            Group all logic related to this feature in a single place
        Benefit
            1)De clutter main app or files unnecessary for this
            2)If implementation wants to be changed, only 1 place to work on
                useEffect
                React-Query
                Other libraries
            3)Re use logic
    Returning array from custom hook
        SITUATION
            Where prop is sent
                Receives type as union number | string
            Where prop is used
                Props is defined as what it should be ideally
        PROB
            Both come into conflict and must be addressed
        SOLU
            Tuple will provide ideal type for each
                return [jobItemsSliced,isLoading] as const
    Key Prop
        Funny enough, it must be given but react won't pass it. 
        It won't be received on the component definition side. 
    Window object
        Global namespace with global variables and functions as properties.
        
        1)size and position
        2)document and DOM access
            .document  -> html DOM
            .location  -> current URL(protocol, hosty)
                1).href      -> get or set URL  
                2).reload()  -> reload page
                3).assign()  -> navigate to new URL
                4).replace() -> replaces in url in history, no back option  
            .history   -> browser session history
            .navigator -> browser and device info
    Window.location.hash
        Fragment identifier in a URL, part after the #.
        Write
            window.location.has = "jobId"
        Read
            const id=window.location.hash.substring(1)
        Reacting to hash change
            window.addEventListener("hashchange", () => {...})
    Returning function in useEffect
        Remember to clean up after side effects
        EXAMPLE
            If timeout not cleaned, will run all the timeouts of the ammounts of re renders the component had. 
    Types consistency is enforced
        A type  defined before (activeID = number | null) will force you to keep that same type and work around it. (useJobIems(activeID))
    Excellent useCase for Type Intersection
        Types where you fetch surface info on list
        And then fetch details for the details page
    Importing same name type as component
        import {type JobItemContent}
    State<type | null> and Type Narrow
        Always make sure you contemplate the null case of the state first
        When you look for something inside state, if null is not dealed with first, it will give error.
    isLoading
        Multiple isLoading must be in separate files.        
    Order of logic / conditional 
        Negatvie cases first
            isLoading?
            !var
            positive return for component
    Debounce searchText
        Technique to limit # of times a function is executed.
        Ensures function is only executed after a specific delay.
        HOW
            1)each time event is triggered, timer is set.
            2)if event is triggered before timer ends, time restarts.
            3)func executes only after timer has finished wihtout interruptions.
            4)must clean each deprecated timeout or they will all finish executing and the debounce will be useless.
        WHEN
            1)search input
            2)button click prevention
            3)windowx resize
    C-hooks library
        usehooks-ts.com
    Tip when determining where to locate hooks or functions
        Look at where you already have access to data
        EXAMPLE
            debouncesearchtext can be in app b/c searchtext is already there.
    SetTimeout in Reac
        Accumulated timeouts will execute.

        SOLUTION
            Removal of each of the unnecessary calls. 
            1)store id of each
            2)return a function that executes clearTimeout with that id.
    Non-Null Assertion (!)
        The non-null assertion operator (!) tells TypeScript:
            “I am 100% sure this value is NOT null or undefined.”
            Use with caution—it bypasses TypeScript’s safety checks.
        HOW TO USE
            cases in which type is something | null as substitute for guard clause
        GOOD EXAMPLE
            Inside react query query-fn to avoid guard clausing the number | null activeID
    Sending complex info as prop
        If it is a list, and you are rendering a component, send the entire object as an item and destructure on the other side. 
    Typing API Resp
        Use Promise Generic
            Promise<>
        Type your data
           Type = Data 
        Use the data as the type for the Promise Generic
            Promise<Data>
    Using !resp.ok
        Can save you an unnecessary guard clause.
        HOW
            If fetch depends on paramater that can be null: data | null, it handles this case for you.
        RESULTING TYPE NARROW
            Allows ts too infer that null case is handled, and data will always be truthy
    what browser does in the 500 errors
        Automatically throws Error() like we do in the other server codes\
    Possibility of undefined, methods depending on value being array 
        ?. optional chain
        Establishing the undefined case means type will be type | undefined
            PROBLEM
                In the other side, data has not been typed as counting the undefined scenario
            SOLUTION
                Short circuit ||
                    if undefined || [] / 0
    Unknown ts type
        opposite of any, can't do anything, everything throws errors.
        WHY
            type of paramter for the onError function of React Query can be anything even though react hot toast expects a specific type.
            FIX
                Ts needs to specifically know what it is dealing with at all times.
                Type narrow 
            EXTRA DATA
                React Query new versions make the error parameter the default Error object type.
    Client vs server side pagination
        client
            Implemented client, all calculations done on the clien
            Receive entire package of data
            can slow down the client if too much data
        server
            server only sends the data for that page, fetches every page.
            better for massive data
    Ts literal + union type good use
        const [sortBy, setSortBy] = useState<'relevant' | 'recent'>('relevant')
    [...(jobItems || [])]
        for mutating methods its best to destructure and create a new
        must guard for undefined case and assure that an empty array will be returned []
        Better to mutate so reference to variable changes and useMemo is not affected
    Can use variables to send booleans as props
        isActive={sortOption === "relevant"}
    e.stopPropagation() special anchor behavior
        e.preventDefault()
    LS in useEffect
        IF NOT
            async nature of state will make it really hard to have properly synced.
        IF 
            Will be in sync without much hastle
    Function as initial value in useState
        BENEFIT
            Only runs on mount, avoids needless computation on every re render.
            Performance benefits.
    Typing a prop and passing that data + more
        Ts will not complain as long as what was specified is included minimum
        You can configure ts too complain
    e.target.closest(".classname")
        Returns true if event comes from within the element with the classname provided
    Refs
        Passing a ref as a prop and consuming
            1)ref is received separate from props
            2)must wrap component in forwarefRef(function(props, ref){
            })
        Type the ref
            Generics in the function provided by react
                forwardRef<HTMLDivElement>
        Type the prop
            forwardRef<HTMLDivElement, {here}
        Irony in placement
            typing
                ref = 1 
                props = 2
            function parameters
                props = 1
                ref =2 
    Indicating a required parameter will not be used
        _
        function(_, ref)
        This way the eslint or ts error message will stop appearing.
    Features so common there are custom hooks already
        1)useDebounce()
        2)useLocalStorage()
        3)useClickOutside()
    Trick when refactoring a function into a custom hook
        Generalize the already specific result
    createPortal
        Way to locate pop ups and popovers in the entire document.body while still having them in the component they should be in.
    Wrapper for reusable Component
        Create a wrapper and render reusable component inside to provide the data through props
        Implementation
            App
                <JobListSearch/>
            JobListSearch
                Data
                    const {isLoading, jobItemsSliced} = useJobItemsContext()
                Render
                    <JobList jobItems={jobItemsSliced} isLoading={isLoading} />
            BookmarkPopover
                Data
                    const { bookmarkedJobItems, isLoading } = useBookmarkedIdsContext();
                Render
                    <JobList jobItems={bookmarkedJobItems} isLoading={isLoading} />
    Efficiency = avoid unnecessary
        1)re renders
            a)context and encapsulation with states 
        2)calculations
            a)use memo to avoid calculating unless dependencies change
        3)functions affecting calculations / states
            a)use callback to avoid functions being created on every re render
    Importance of updating objects and arrays with new ones
        If done on the original (ex: sorting), the reference to that variable does not change. 
        MEANING
            Dependencies will not be triggered by the change in it, b/c they will register as if it is the same.
    UseState new updated value 
        Accesible only in new render, that is why console logs previous value first.
    useRef
        If no state is used to cause re render, we will log new value for useRef but the UI will never show that value.
        The only thing that causes re renders is state
    useCallback
        Functions get recreated on every re render, even if they dont change when memoized, they will cause a re calculation and that will cause a re render.
    useMemo
        Don't re calculate value unless dependencies change to avoid app getting stuck.

NEXT JS(BEGINNER TO INTERMEDIATE)
----------------------

GAME CHANGER
    Can build full stack apps, no need for separate back end anymore

WHAT
    React framework for full stack applications. 

    HOW
        React | Components to Build UI
        Next | additional features and optimizations

REACT DISSADVANTAGES
    1)Has to execute the js code and this becomes invisible to the search bots
    2)iniiial paint high load times

HIGH LEVEL OVERVIEW 
    Abstracts away a lot of the network boundary when server side rendering.
    No need to think about a route and serving the html in a traditional manner. 

BENEFITS
    1)Abstracts and auto configures tooling like bundling, compiling and more. 
    2)Allows to spend more time on building rather than configuring.
    
CREATE PROJECT
    npx create-next-app@latest .
    
1)ROUTING AND NAGIVATION

    ROUTING
    App routing system based on react server components.

    HOW
        Uses folders instead of files to to define routes.
        MATCHING
            Uses a page.js/tsx file inside a folder to represent the route
        ROOT ROUTE
            /app
            ├── page.js             # Renders at "/"
        ROUTES
            ├── about
            │   ├── page.js         # Renders at "/about"
        DYNAMIC ROUTE
            ├── blog
            │   ├── page.js         # Renders at "/blog"
            │   ├── [id]
            │   │   ├── page.js     # Renders at "/blog/:id"

        Dynamic Routes
            When you don't know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build time.

            CREATING DYNAMIC SEGMENT
                A Dynamic Segment can be created by wrapping a folder's name in square brackets: [folderName]. For example, [id] or [slug].

            USING THE DYNAMIC SEGMENT
                Dynamic Segments are passed as the params prop to layout, page, route, and generateMetadata functions.

                EXAMPLE
                    export default async function Page({
                        params,
                        }: {
                        params: Promise<{ slug: string }>
                        }) {
                        const { slug } = await params
                        return <div>My Post: {slug}</div>
                    }
        
                GTK
                    Since the params prop is a promise. You must use async/await or React's use function to access the values.


    
        LAYOUT
            The new root component(main.js) rendering {children} that are all the pages.
                    
            REUSABLE ELEMENTS
                This is the component that will have elements like header and footer.

                EXAMPLE(in layout.tsx)
                    return (<>
                        <Header/>
                        {children}
                        <Footer/>
                        </>
                    )

        NESTED LAYOUTS(Different Layouts for Different Sections)
            You can create nested layouts for specific sections (e.g., blog/ has its own layout).

            EXAMPLE
                app/blog/layout.js (Only for Blog Pages)

                export default function BlogLayout({ children }) {
                    return (
                        <section>
                        <h1>Blog Section</h1>
                        {children}
                        </section>
                    );
                }

                Folder structure
                    /vans
                        /deprecated
                            page.tsx(page to render in /vans/deprecate route)
                    layout.tsx(will share components between all pages in the vans folder)
                    page.tsx(main page to render in /vans route)
                        
        SPECIAL FILES
            These files effects are dependent on where they are used. 

            layout
                Will provide shared UI to the pages inside of it.
            pages
                Determines what will be shown based on the folder name(route)
            template
                TBD
            not-found
                Automatically handles every not found URL for the entire application.
                
                BENEFIT
                    No need to manually define the not found component and * url. 

            loading.tsx
                The special file loading.js helps you create meaningful Loading UI with React Suspense. With this convention, you can show an instant loading state from the server while the content of a route segment loads. The new content is automatically swapped in once rendering is complete.

                DIFFENCE
                    Feature	            loading.tsx in Next.js	            Suspense in React
                    Handles async UI?	                Yes                             Yes
                    Works with Server Components?	    Yes	                            Yes
                    Works with Client Components?	    No (only layouts and pages)	    Yes
                    Where it applies	                Whole page or layout	        Specific components
                    Automatically handled?	            Yes (by Next.js)	            No (you manually wrap components)

                3 WAYS OF HANDLING
                    1)without suspense
                        PROBLEMS
                            1)each component has to handle its own loading state and fetch effect
                            2)lots of boilerplate code
                            3)difficult to maintain
                        EXAMPLE(for each component)
                            const [data, setData] = useState(null);
                            const [loading, setLoading] = useState(true);

                             useEffect(() => {
                                fetch('/api/dashboard')
                                .then((res) => res.json())
                                .then((data) => {
                                    setData(data);
                                    setLoading(false);
                                });
                            }, []);

                            if (loading) return <p>Loading dashboard...</p>;

                    2)React suspense(react 18)
                        Introduced to avoid handling loading state manually for every component

                        PROBLEMS
                            1)Only works for client components, not full pages
                            2)requires manual wrapping around components

                    3)Nextjs app router(loading.tsx)
                        Automatic loading UI for pages and layouts
                        Works with server components
                        less boilerplate than suspense for entire pages

                    CONCLUTION
                        suspense
                            for controlling specific component
                        loading
                            for controlling an entire page
            error.js/ts
                Allows to handle unexpected runtime errors and display fallback UI.

                MUST
                    be client component
                
                TYPING
                    export default function Error({
                        error,
                        reset,
                        }: {
                        error: Error & { digest?: string }
                        reset: () => void
                    })
                USAGE
                    Normal writing whatever you want.
                HOW
                    Wraps a segment in an error bounday, pretty much the entire app is wrapped around the boundary. Same functioning as the page. 

                    <ErrorBoundary fallback={<p>Something went wrong</p>}>
                        <Profile />
                    </ErrorBoundary>
                PROPS
                    error
                        instance of the Error object.
                        error.message
                            client components
                                show the original error message
                            server components
                                generic message with an identifier
                        error.digest
                            auto generated hash of the error thrown
                    reset
                        function that will try to re render the component 
                    mmanual sent error
                        any error thrown in the route will be used here.

                        EXAMPLE
                            if(!parsedPage.success){
                                throw new Error('Invalid page number')
                            }
                            result
                                Invalid page number will be shown in the error.js/ts
                    

                BENEFITS
                    centralized
                        instead of separately handling (like loading), it centralizes it in a route or layout.
                    improves ui
                        no more breaking app or blank screen
                    auto passing error to the error file
                        no more manual passing of the object by yourself
                    supports auto recovery 
                        auto provides function to try again 
                    scoped error handling
                        placing it in a specific folder will make it work only there(like loading)

    NAVIGATION
        Way to navigate:
            1)<Link> Component
            2)useRouter hook (Client Components)
            3)redirect function (Server Components)
            4)Using the native History API

        LINK COMPONENT
            The <Link> component is still used for client-side navigation.
            Does not require to=, just href=.

            EXAMPLE
                import Link from "next/link";
                
                export default function Navbar() {
                return (
                    <nav>
                    <Link href="/">Home</Link>
                    <Link href="/about">About</Link>
                    <Link href="/blog">Blog</Link>
                    </nav>
                );
            }

            DIFFERENCES WITH LINK FROM REACT ROUTER
                1)Prefetches pages in prod
                    Meaning most of the work is done when actually clicking it.
                2)Does not work with external link, need anchor tag.

            PROPS
                The following can be passed
                
                Prop	        Example	            Type	            Required
                href	        href="/dashboard"	String or Object	Yes
                replace	        replace={false}	    Boolean	            -
                scroll	        scroll={false}	    Boolean	            -
                prefetch	    prefetch={false}	Boolean or null	    -

            PREFETCH
                WHERE
                    Prod ONLY
                WHEN
                    Link component enters users viewport 
                HOW
                    Prefetches the route it is linking to. 
                    Receives the RSC payload (result of rendering a server component) and puts it in the client-side cache(router cache)
                VALUES
                    null
                        static  -> full route prefetched
                        dynamic -> all static to nearest loading boundary
                    true
                        full for both static and dynamic
                    false
                        never happens

        USEROUTER() -> to be used in client components
            The useRouter hook allows you to programmatically change routes from Client Components.

            EXAMPLE
                'use client'
                import { useRouter } from 'next/navigation'
                
                export default function Page() {
                const router = useRouter()
                
                return (
                    <button type="button" onClick={() => router.push('/dashboard')}>
                    Dashboard
                    </button>
                )
            }
        redirect function -> to be used in server components 
            For Server Components, use the redirect function instead.

            EXAMPLE
                For Server Components, use the redirect function instead.

                 const team = await fetchTeam(id)
                if (!team) {
                    redirect('/join')
                }

        Navigation functions
            usePathname()
                usePathname is a Client Component hook that lets you read the current URL's pathname.

                RETURNS
                    usePathname returns a string of the current URL's pathname. For example: '/'

                EXAMPLE
                    'use client'
 
                    import { usePathname } from 'next/navigation'
                    
                    export default function ExampleClientComponent() {
                    const pathname = usePathname()
                    return <p>Current pathname: {pathname}</p>
                    }
        notFound()
            Invoking the notFound() function:
                1)throws: a NEXT_NOT_FOUND error
                2)terminates rendering of the route segment in which it was thrown. 
            Specifying a not-found file allows you to gracefully handle such errors by rendering a Not Found UI within the segment.
                    
            EXAMPLE
                if (!user) {
                    notFound()
                }
                        
        

    
2)METADATA
    Metadata in Next.js helps define SEO-related information, such as page titles, descriptions, Open Graph (OG) tags, and favicons.

    Ways next provides to handle metadata
        1)static
            Defined in metadata object in page or layout
            HOW
                React has predefined interfaces that convert that object to the required html. As long as the html exists, you can write the property and provide the values.

                EXAMPLE
                import type { Metadata } from 'next'

                export const metadata: Metadata = {
                    title: '...',
                    description: '...',
                }
                
                export default function Page() {}

        2)dynamic
            You can use generateMetadata function to fetch metadata that requires dynamic values.

            EXAMPLE
                export function generateMetadata({params}: EventsPageProps) {
                const {city} = params

                return {
                    title: `Events in ${city.charAt(0).toUpperCase() + city.substring(1)}`
                    }
                }

            Can also fetch inside this dynamic function by fetching again.

                PROBLEM
                    what about performance doing a double fetch?

                SOLUTION
                    Data cache, will fetch only once and memoize the data and will never re fetch twice. 
                
                
        
    FAVICON
        Whatever has "favicon.ico" name inside the src folder will be the default favicon for the page.
            
3)STYLING
    TAILWIND CSS
        Nextjs already integrates tailwind.css and removes configuration.

        BENEFIT OF TAILWIND
            Dictionary of classed already created, just use them.

        

4)<IMAGE/>
    Provides custom tag which is optimized replacement for standard HTMl <img> tag.

    FEATURES
        1)optimized loading
        2)automatic resizing
        3)performance boost 
        4)blur replacement
        5)built in responsive support

    HOW TO USE
        import Image from "next/image";

        <Image (REQUIRDE PROPERTIES) 
            src="/my-image.jpg" // Local image in the public/ folder 
            alt="My beautiful image"
            width={500} // Image width in pixels
            height={300} // Image height in pixels
      />
    LOCAL
        To use a local image, import your .jpg, .png, or .webp image files from your public folder.

        import Image from 'next/image'
        import profilePic from './me.png'

        <Image
            src={profilePic}
            alt="Picture of the author"
            // width={500} automatically provided
            // height={500} automatically provided
            // blurDataURL="data:..." automatically provided
            // placeholder="blur" // Optional blur-up while loading
        />

    PROPS
        FILL
            This makes the image automatically stretch to cover its parent container.
            The parent must have position: relative or another positioning style for it to work.
            Useful when width and height unknown
            assings by default
                position absolute 
                object fit fill 
        
        sizes="(max-width: 1280px) 100vw, 1280px"
            This tells the browser how much space the image should take up at different screen sizes.

            If the viewport width is 1280px or less, the image takes 100% of the viewport width (100vw).
            If the viewport width is greater than 1280px, the image is fixed at 1280px wide.

            BENEFIT
                allows the browser to download iamge real size, without it, it downloads it in the size of the viewport.

        quality
            The quality of the optimized image, an integer between 1 and 100, where 100 is the best quality and therefore largest file size. Defaults to 75.

        priority
            When true, Next.js will preload the image. 
            Lazy loading is automatically disabled for images using priority. 
            
            WHEN TO USE
                You should use the priority property on any image detected as the Largest Contentful Paint (LCP) element. 
                It may be appropriate to have multiple priority images, as different images may be the LCP element for different viewport sizes.
            
            




    EXTERNAL
        For remote images (like from a CDN or API), allow them in next.config.js.

        CONFIG FILE
            const nextConfig = {
                images: {
                    remotePatterns: [
                    {
                        protocol: "https",
                        hostname: "example.com", // Change to your image host
                    },
                    ],
                },
            };
        USING IMAGE
            <Image 
                src="https://example.com/image.jpg" 
                alt="External Image"
                width={400} 
                height={250} 
            />
        
5)CLIENT VS SERVER COMPONENTS
    Components designed for specific purposes to improve performance and scalability.

    SERVER COMPONENTS
        Rendered in the server and sent as html to the client.

        NO ACCESS TO BROWSER FEATURES
            1)DOM
            2)events
            3)local state

        BENEFIT
            GET requests
                Off load the get requests in the server
        
        FEATURES
            1)allows to offload more logic to the server, increasing performance in user device
            2)faster load times
            3)can fetch data on the server without client side involvement
            4)can keep large dependencies on the server

        USE CASES
            1)fetch data
            2)access backend resource
            3)access sensitive information(access tokens, api keys)
            4)large dependencies

        WHEN BECOMING A SERVER COMPONENT
            Everything inside the app/ directory are server components by default(CHILDREN as well)

        HOW DOES NEXT ABSTRACT
            1)Manual Routing:
                Next auto routes server components
                Express would need to manually define them
            2)Auto data fetching
                Next server compnents can fetch data and render seemlessly
                Expres needs to manually fetch data and pass it as prop

        FETCHING DATA(GET REQUEST)
            BENEFITS
                1)can console log
                2)no need for useEffect or useState or any hook 
                3)reduce bundle js sent to the client
                4)api keys are a lot more convenient to use
                5)data is stored normally in variables, no hooks
            HOW
                make compononet function async
                    export default async function EventsPage({params}: EventsPageProps) {...}
                fetch normally
                    const response = await fetch(`https://bytegrad.com/course-assets/projects/evento/api/events?city=${city}`)
                    const events = await response.json()
                    console.log(events)

        RE RENDERING SERVER COMPONENTS WITH NO STATE
            server components use URL as source of truth

            WHEN
                If this component is a server component (which it likely is, since it’s an async function and has no client-side state), Next.js will re-fetch and re-render whenever the URL parameters change.

            PROBLEM
                We lose the fallback / loading indicator with server components and pagination.

            SOLUTION
                FIRST REAL good use of the key prop
                PURPOSE
                    to indicate something is unique, and can be used as dependency array
                SYNTAX
                    key={city + page}
                HOW
                    The key ensures React treats it as a new component, forcing a remount and re-triggering <Suspense>.

    CLIENT COMPONENT
        Traditional client rendered react component meant for interactity:
            1)click events
            2)form submission
            3)state management

        WHAT DOES IT MEAN FOR NEXTJS
            Indication that component will be rendered and executed in the browser.

        FEATURES
            1)rendered on client
            2)access to browser features
                1)dom
                2)events
                3)local state
            3)js to make components interactive

        USE CASES
            1)interactivity
            2)hooks and lifecycle effects

        HOW TO MAKE SOMETHING A CLIENT COMPONENT
            1)IMPORTED COMPONENTS
                Any component imported to a client component will become client component.
            2)SPECIFY 
                To mark as client, add the 'use-client' directive top of the file.
        WHERE TO HAVE CLIENT COMPONENTS 
            Outside edgess of the tree, the leaves.
                
            EXAMPLE
                Button component, nothing that will affect other major components. 

        HOW TO HAVE A SERVER COMPONENT INSIDE A CLIENT COMPONENT
            CHILDREN PROP 
                Using the {children} prop inside a client component WON'T make it a client component.
            
        CONTEXT OF INSTANTIATION
            A component can be rendered in both contexts, being client in 1 instance and server in another. 

    HOW TO HAVE SERVER -> CLIENT -> SERVER
        1)Server -> by default will be 
        2)Client in server1 -> use client 
        3)Server in Client -> render as children prop



6)SERVER ACTIONS(POST,PUT,DELETE)
    Feature that allows to define functions in the server that can be called from the client, to perform server side operations without the need for API routes. 

    BENEFIT
        Meant to replace endpoints that are only used for POST PUT DELETE ACTIONS, unnecesarry and redundnant.

    WHY
        Improve 
            1)experience
            2)performance 
        HOW
            simplifying handling of:   
                1)server side logic 
                2)reducing boilerplate code
        
    FEATURES
        1)no need to api routes
            eliminate need for custom /api/* to handle server logic. 
            logic can be directly defined in sscomponents.
        2)auto server execution
            server actions are auto executed on the server when invoked by the client. 
        3)simplified code
            reduce boilerplate code
        4)rssc integration
            ssa work seemless with rssc, natural extension of that. 

    HOW TO USE
        Mark function with @server
            'use server' directive at top of file to indicate server action. 
        Trigger action from client
            Call the action in the CSC
        Handle response
            Once executed, handle response on the client side.

7)SUSPENSE AND STREAMING
    Cutting edge features that leverage the latest advancement in React for working with SSR

    WHY
        1)optimize performance
        2)improve UX 

    SUSPENSE
        Allows to delay rendering of component until some async data is ready. 

        WHY
            Prevents the UI from rendering incomplete components

        HOW DOES IT WORK(NATIVE / REACT)
            Wraps a component that may include async logic and provides a fallback to render in its place. 

            EXAMPLE
                <Suspense fallback={<p>Loading...</p>}>
                    <ProductList />
                </Suspense>

        NEXT JS implementation
            Loading.tsx
                By using the loading component, next js automatically wraps the page in a suspense and provides the loading as fallback.

            EXAMPLE
                <Suspense fallback={<Loading/>}>
                    <Page/>
                </Suspense>

        USE CASE
            Show the page and suspense the component with the fetch that takes time to finish.

        Definining own boundaries with suspense
            Benefit
                Instead of loading for the entire page, it will load what is availalble and provide suspense for the missing loading component.

            Requirements for pattern to load
                1)move aysnc operation to component that will load
                    ej: From Events city page -> EventsList
            Manually define suspense for component that needs it 
                <Suspense fallback={<LoadingCity/>}>
                    <EventsPage/>
                </Suspense>
            
    STREAMING
        Render content on the server and send it to the client progresively as it is being generated instead of waiting for the entire page to be generated and sent to the client.

        WHY
            Allows the user to start interacting with it while other parts are still being fetched. 

        HOW
            React Suspense + React Server Components
        
        BENEFITS
            1)Faster TTI 
            2)optimized SSR
            3)less blocking

    COMPLEMENTATION OF BOTH
        Suspense
            handles async data fetching smoothly 
        Streaming
            progressively delivers the rendered content from the server

8)CACHING
    Instant auto caching on client of fetch requests. 

    REMOVES
        1)after 5min
        2)onReload

    SPECIFY IN THE LITERAL FETCH REQUEST AS AN OPTION PARAM (only works in nextjs) 
        {
            cache: "no-cache"
        }
    SPECIFY WHEN TO REFETCH 
        {
            next:{
                revalidate: 3600
            }
        }

    TYPES OF CACHE IN SERVER
        1)data cache
            Even if component needs to be rendered again, data will persist. 
        2)full router cache
            means the page and all its children compoonents will not run every time and will be frozen
    
9)STATIC & DYNAMIC RENDERING
    They determine HOW and WHEN a page is built and delivered to the user. 

    STATIC(prod)
        WHEN
            Static rendering means that HTML is generated at build time, before the request is made by the user.
        
        HOW
            The page is generated once, and it is then served from a static file to the user for every request, which makes it very fast.

    DYNAMIC(dev)
        WHEN
            Dynamic rendering means the HTML is generated at request time on the server, for each individual request.
        HOW
            The page is built dynamically based on the request parameters (e.g., query params, headers, etc.) and delivered to the user at runtime.

        HOW TO FORCE A COMPONENT TO BE DYNAMIC
            export const dynamic = "force-dynamic" at top of file

        PRE-GENERATING OF POPULAR ROUTES 
            Dynamic routes will not be statically rendered during build. However, you can still statically render some popular routes. 

            generateStaticParams()
                Used with dynamic route segments to statically generate routes at build time INSTEAD of on-demand at request time. 
                
                EXAMPLE
                    // Return a list of `params` to populate the [slug] dynamic segment
                        export async function generateStaticParams() {
                        const posts = await fetch('https://.../posts').then((res) => res.json())
                        
                        return posts.map((post) => ({
                            slug: post.slug,
                        }))
                    }
                RETURNS
                    Array of objects
                        each object
                            represents the populated dynamic segment of a single route. 
                            Each property
                                is a dynamic segmenet to be filled in for the route.
                
            
    STATIC VS DYNAMIC
        Feature	                        Static Rendering (SSG)	                                Dynamic Rendering (SSR)
        When is the HTML generated?	    At build time	                                        At request time
        Data fetching	                Fetches data only at build time using getStaticProps	Fetches data on each request using getServerSideProps
        Performance	                    Very fast — pre-built HTML served	                    Slower — server must generate HTML for each request
        Content freshness	            Content might be outdated (use revalidation)	        Content is always fresh and up-to-date
        Caching	                        Cached on CDN or server	                                Typically not cached unless manually configured
        Best for	                    Static content (e.g., blogs, landing pages)	            Dynamic content (e.g., user profiles, real-time data)
    
10)MIDDLEWARE
    Middleware allows you to run code before a request is completed. Then, based on the incoming request, you can modify the response by:
        1)rewriting
        2)redirecting
        3)modifying the request or response headers
        4)or responding directly.
    
    COMMON USE CASES
        1)authentication
            ensure user identify
        2)authorization
            grant access to specific pages or routes
        3)server side redirects
            redirecting users in the server directly
        4)path rewriting

    Convention
        Use the file middleware.js/ts in the root of the project to define middleware.
            Limit
                Only 1 file is supported per project
            Solution
                modularity
                    break them into modules in different files and import them in the middleware.js/ts
    TYPES
        import { NextResponse } from 'next/server'
        import type { NextRequest } from 'next/server'
    EXAMPLE
        This function can be marked `async` if using `await` inside
            export function middleware(request: NextRequest) {
            return NextResponse.redirect(new URL('/home', request.url))
        }
    NEXTRESPONSE
        The NextResponse API allows you to:
            redirect the incoming request to a different URL
            rewrite the response by displaying a given URL
            Set request headers for API Routes, getServerSideProps, and rewrite destinations
            Set response cookies
            Set response headers
    WHERE TO USE
        Use the file middleware.ts (or .js) in the root of your project to define Middleware. For example, at the same level as app or pages, or inside src if applicable.
    
    WHEN IS IT INVOKED
        Middleware will be invoked for every route in your project. 
        
        B/C OF THIS IS CRUTIAL TO
            Use matchers to precisely target or exclude specific routes. 

            EXECUTION ORDER OF MATCHERS
                headers from next.config.js
                redirects from next.config.js
                Middleware (rewrites, redirects, etc.)
                beforeFiles (rewrites) from next.config.js
                Filesystem routes (public/, _next/static/, pages/, app/, etc.)
                afterFiles (rewrites) from next.config.js
                Dynamic Routes (/blog/[slug])
                fallback (rewrites) from next.config.js

    WAYS TO DEFINE MATCH
        1)Custom matcher config
        2)Conditional statements

        CUSTOM MATCHER CONFIG
            matcher allows you to filter Middleware to run on specific paths.

            SINGLE
                export const config = {
                    matcher: '/about/:path*',
                }

            MULTIPLE
                export const config = {
                    matcher: ['/about/:path*', '/dashboard/:path*'],
                }
        CONDITIONAL
            
            
        
        


                        
    USE CASE
        1)check if logged in 
    
    EXAMPLE
        export function middleware(request: NexRequest) {
            const isAuthenticated = false
            if(!isAuthenticated) {
                return NextResponse.redirect("/login")
            }
            return NextResponse.next()
        }

    AUTH LIBRARIES
        1)kinde
        2)nextAuth

11)FOLDER STRUCTURE
    ...
12)PRODUCTION: BUILD AND DEPLOYING
    STATIC EXPORT
        Only html, css, js files

        HOW
            next.config.js file
                output: "export" 
                unoptimized: true

        DOWNSIDE
            Loss in all server features

    NEXTJS app = nodejs app
        
    .NEXT folder
        Folder with the build app

    .env (can be uploaded)
        DATABASE_URL="file:./dev.db"
    
    .env.local(private)
        To be protected always

13)@/path
    starts at the source folder so it is easier to know what is being imported and from where

    DEFIND IN TSCONFIG
        "paths": {
            "@/*": ["./src/*"]
        }

TYPE OVER INTERFACE
    1)intersection instead of extension
    2)all data types
    3)unions
    4)utility types
    5)tuples
    6)not merged like interfaces(by redeclaration)
    7)

GIT NEW KNOWLEDGE
    git reset --hard COMMIT_THAT_REMAINS(remove commits from local repo)
    git push origin BRANCH_NAME --force(push commits to remote repo)

P6 - EVENTO 
----------------
TO LEARN:

1)tailwind
    Adding space between children
        space-x-4
    configuring accent color
        config file
            theme: {
                extend: {
                    colors: {
                        accent: "#a4f839",
                    },
                },
            }
        consume in file
            text-accent 
        styling rules learned and used
        overflow-y-scroll
            has scrollbar always available for specified element
    responsiveness
        px-4 md:px-2
            Start with the smaller screen value, and then specify bigger sizes
    hover styles
        hover:[rule]
    classname prop combined with classname styling
        cn function created combining clsx(conditional styling) and twmerge(resolving class conflicts)
    @apply rule
        In global css file create custom rule and @apply the styling requested, this will allow for the use in the rest of the app

        EXAMPLE
            .state-effects{
                @apply hover:scale-105 transition active:scale-[1.02]
            }
2)clsx
    Is a simple library that lets you toggle class names easily. You can install it using npm install clsx
    
    PARAMETER
        takes in [] or {} 
    RETURNS
        ""
3)framer motion
    powerful animation library for React that allows developers to create smooth, modern animations with minimal effort.

    Why 
        Declarative animations 
            Define animations in a simple and readable way.
        Smooth performance 
            Uses requestAnimationFrame for fluid animations.
        Variants system 
            Organize animations in a structured way.
        Gestures & interactions 
            Handle hover, drag, tap, and scroll animations easily.
        Layout animations 
            Animate elements as they reflow in the layout.

    When 
        For micro-interactions (buttons, hover effects, modal transitions).
        For page transitions in single-page applications (SPAs) and Next.js.
        For scroll animations (revealing elements on scroll).
        For drag & drop animations (like Trello cards).

    CONTENT
        animations
        variants
        gestures

    
4)tailwind merge
    is a utility function that helps resolve class conflicts when using Tailwind CSS. It's commonly used to merge and deduplicate conflicting Tailwind classes dynamically.

    why
        1)Avoids Conflicting Classes
        2)Improves Code Readability & Maintainability
        3)Helpful in Dynamic Styling
        4)combines with clsx
    
    EXAMPLE
        <h1 className={twMerge("text-3xl lg:text-6xl font-bold tracking-tight", className)}>{children}</h1>
5)cn()
    The cn function (short for "class names") is a utility function often used in React + Tailwind CSS projects to manage class names dynamically. It helps merge, conditionally apply, and deduplicate Tailwind classes.

    EXAMPLE
        import { twMerge } from "tailwind-merge";
        import clsx, { ClassValue } from "clsx";

        export function cn(...inputs: ClassValue[]) {
            return twMerge(clsx(inputs));
        }
    clsx(): Handles conditional class logic (e.g., isActive && "bg-blue-500").
    twMerge(): Deduplicates and resolves conflicting Tailwind classes.
        
6)Skeleton        
    Placeholder UI while the actual component is being loaded. 

    WHY
        so users can understand what to expect before the data is fully loaded. 

    WHEN
        in places where loading data may take up a little time.
7)sqlite
    Lightweight, self-contained, serverless db engine widely used for applications needing a simple, efficient and reliable way to store and manage data. 

    WHAT
        Database engine
            RDBMS that follows SQL for managing data.
        Serverless
            unlike MySQL or PostgreSQL does not require a separate server. Operates directly on a database file.
        File Based
            All data, including tables, indexes, schemas are stored in a single .sqlite or .db file.
        Lightweight
            Size < 1mb
            Requires minimal setup
        Cross-Platform
            Works on virtually any platform, desktop to mobile.
    WHY
        Ease   
            No config or install needed, just include the SQLite library and start working.
            Ideal for beginners
        Embedded
            Can be directly embedded into an application
        Fast 
            Optimized for performance
            ACID compliant
        Free & Open Source
            Source code is in the public domain
        Use Cases
            Small-scale projects or prototyping before moving to larger database

    HOW
        Database File
            Operates on a single file. "my_database.sqlite" contains all your data.
        SQL Syntax
            Uses standard SQL to interact with database.
        Programming Interface 
            accessed via:
                CLI
                Integrated into programming language

8)prisma
    Open source ORM for Node.js and Typescript that simplifies db access and management. 

    COMPATIBLE WITH
        PostgreSQL, MySQL, SQLite, SQL Server and Mongo

    INITIALIZING
        npx prisma init --datasource-provider sqlite
            CREATES
                .env -> add db url 
                prisma (folder)
                    schema.prisma -> define client & db
        npx prisma db pull (if db already has data)
            pulls data and auto generates schema
    
    KEY FEATURES
        Type Safety
            Auto generates Ts types for db schema, means you get:
                1)autocompletion
                2)error checking
                3)refactoring support 

            USAGE
                Replace previous type with primsa model

                EXAMPLE
                    import { Evento } from "@/lib/types";
                    import { Evento } from "@prisma/client";
                
            EXAMPLE
                fetch calls before returned any
                prisma querying is already typed
        
        Query Simplicity
            Prisma
                const users = await prisma.user.findMany({
                    where: {
                        age: { gt: 18 },
                    },
                    select: {
                        name: true,
                        email: true,
                    },
                });
            Mongoose
                const users = await User.find({ age: { $gt: 18 } }).select("name email");

        Relations (Prisma’s Built-in Relations)
            Prisma
                const posts = await prisma.user.findUnique({
                    where: { id: 1 },
                    include: { posts: true }, // Fetch related posts
                });
            Mongoose
                const posts = await User.findById(1).populate("posts").exec();
        
        Migrations natively
            Prisma
                npx prisma migrate dev --name init
            Mongoose
                Mongoose doesn’t support migrations natively. You need third-party tools like migrate-mongo.

    Scheming db with Prisma Schema
        Prisma uses a schema file (schema.prisma) to define your database models. You define:
            1)models
            2)relationships
            3)data constraints
        SYNTAX
            model Table {
                columns -> datatype -> constraints
                id  -> Int  -> @id @default(autoincrement())

                RELATION
                weaponId Weapon @relation(fields:[weaponId], references:[id])
                @@index(weaponId)
            }   
            model Weapon {
                id  -> Int  -> @id @default(autoincrement())
            }

    Prisma Migrate
        Powerful tool for handling db migration.

        HOW
            1)version control db schema
            2)track changes
            3)migrate safely across environemnts
        
        KEY
            Auto generates migration files based on changes to prisma schema and apply them to the db.
            In other words
                Maintains migration as db evolves 

        npx prisma migrate
            npx prisma migrate dev --name init

            This command did three things:
                It created a new SQL migration file for this migration in the prisma/migrations directory.
                It executed the SQL migration file against the database.
                It ran (prisma generate) under the hood (which installed the @prisma/client package and generated a tailored Prisma Client API based on your models).
                    This is what provides the autocomplete for you based on your models
        Db push vs migrate
            npx prisma db push	
                Syncs schema changes without migrations	
                When
                    During development when making quick changes
                How 
                    Directly updates the database schema to match schema.prisma without keeping migration history
                Risk
                    If you delete a field, data is lost immediately.
            npx prisma migrate	
                Creates migrations to track schema changes	
                When
                    When working in production or version-controlled projects	
                How
                    Generates SQL migration files and applies them to keep track of changes
                Benefits
                    It creates migration files and applies them.
                    Keeps a history of changes (useful for teamwork and production).
                    Prisma warns if there are destructive changes (e.g., deleting a column).
                    You can rollback changes if needed.
    Prisma Studio
        Visual Interface for interactin with db.
        
        ALLOWS
            1)browse data
            2)run queries
            3)perfrom CRUD

        COMMAND
            npx prisma studio 

    Prisma Client
        Type safe db client that allows for you to interact with your db using Js or Ts.

        HOW
            Abstracts the SQL queries and provides fluent API to... in db
                1)query
                2)create
                3)update
                4)delete

        EXAMPLE
            const prisma = new PrismaClient();
            / Query all users
            const users = await prisma.user.findMany();
            // Create a new user
            const newUser = await prisma.user.create({
                data: {
                    name: 'John Doe',
                    email: 'johndoe@example.com',
                },
            });            
    
    Prisma seeding
        Prisma provides a built-in way to seed a database using a seed script.

        HOW
            1)Define Your Seed Data (prisma/seed.ts or seed.js)
            2)Configure the package.json Script
                 "prisma": {
                    "seed": "ts-node --compiler-options {\"module\":\"CommonJS\"} prisma/seed.ts"
                }
            *)install ts-node if you have not
                npm install -D ts-node
            3)Run the Seed Script
                npx prisma db seed

    Methods used from API        
        Upsert
            Will not create new if record already exists.
        Get 1 
            findUnique()
        Get all
            findMany()
        filter
            where{prop: value}
        sort
            orderBy:{
                date:"asc"
            }
        count
            Use count() to count the number of records or non-null field values. 
                const userCount = await prisma.user.count()
            BENEFIT
                dont have to do logic on the client side
        
9)zod
    Zod is a TypeScript-first schema declaration and validation library.
    
    ALLOWS
        1)define data schemas
        2)validate inputs
        3)infer TypeScript types all in one place.
    FEATURES
        1)TypeScript-first (auto-infers types) / NO NEED FOR SEPARATE TYPES(like prisma i guess)
        2)No external dependencies
        3)Chainable, expressive validation API
        4)Works both server-side and client-side(node, react/next)
        5)Detailled error messages and autocompletion
    WHY
        Data VALIDATION is necessary to ensure data INTEGRITY.
    
        WHETHER ... you NEED a reliable way to check data is structured correctly.
            1)handling api requests
            2)form validation
            3)db interactions

   BEST FOR
        1)TypeScript-heavy projects
        2)API validation (Express, Next.js)
        3)Form validation (React, Vue)
        4)Schema-based data validation
    
    WITHOUT
        You'd have to manually:
            1) check types
            2)handle erros
            3)write a lot of boilerplate code
    WITH
        Declarative way to...schemas
            1)DEFINE
            2)ENFORCE   
    HOW
        uses schema definitions to validate data and infer ts types
            
        DEFINE SCHEMA
            const userSchema = z.object({
                name: z.string(),
                age: z.number().min(18), // Must be at least 18
                email: z.string().email(), // Must be a valid email
            });
        PARSE
            const result = userSchema.safeParse({ name: "John", age: 25, email: "john@example.com" });
        VALIDATE
            if (result.success) {
                console.log("Valid data:", result.data);
            } else {
                console.error("Validation errors:", result.error);
            }
    
    INSTALL
        npm i zod



10)vercel


FEATURES
--------
Serving not found route
    WHEN
        if (!event) -> no matching route param
    HOW
        import { notFound } from "next/navigation";
        return notFound();
    IMPORTANT
        if it is not imported from next/navigation it will not work. 


Server Side Pagination
    WHY
        To load only what is necessary. Too many records will slow the page down.
    searchParams
        provided to server components just like params
    type searchParams
        type SearchParams = {
            searchParams: {[key: string]: string | string[] | undefined }
        }
    send as page prop to eventslist
        page={+page}
    consume in eventslist
        EventsList({city, page}: EventsListProps)
    send to getEvents util function
        getEvents(city, page)
    provide to take as number for prisma fetch
        LIMIT IN PRISMA
            take
                provide PAGE
    PaginationControls component
        Links
            href
                const previousPath = page > 1 ? `/events/${city}?page=${page-1}` : ""
                const nextPath =`/events/${city}/?page=${page+1}`
            icons
                Install radix
                    npm i @radix-ui/react-icons
    Benefit of server side pagination
        almost no logic in the client, server handles most of it.
        
Zod validation in evento for incoming data 
    WHY
        1)page number
            1)page number is int
            2)page number is > 0 
        2)search form
            

    EXAMPLE
        const pageNumberSchema = z.coerce.number().int().positive().optional()
          if(!parsedPage.success){
            throw new Error('Invalid page number')
        }const parsedPage = pageNumberSchema.safeParse(searchParams.page)
    
Middleware in evento(use cases, redirecting)
    if user visits /events -> redirect to /events/all

    
    
LEARNED SUMMARY
    Always wrap inputs in form
        No matter where they are, an input should never go without a form.
    Content Layout Shift(CLS)
        Shifting of content when rendering.
    Nav usage
        where the links are located, this could mean leaving the logo outside.
    React & next nav links
        Information is extracted away in arrays to map
    small tag
        auto smaller font size compared to parent element
    condition for m-auto to work
        parent must be flex container in order to full utilize entire height with min-h-screen
    bigger screens
        more padding
        more space between elements
    Work methodology
        hardcored and then dynamic
    making sure lists are good
        just render the raw data without the styling and components
    Sending complex info as prop
        If it is a list, and you are rendering a component, send the entire object as an item and destructure on the other side. 
    flex shorthand default
        flex-grow: 0: Flex items do not grow to fill the available space.
        flex-shrink: 1: Flex items can shrink to fit into the container.
        flex-basis: auto: The initial size of the flex items is based on their content.
    flex 1
        flex-grow: 1;
        flex-shrink: 1;
        flex-basis: 0%;
    using flex 1
        suppose you have 2 children in a flex parent
        1 has a fixed height and the other flex 1, that will grow to fill the rest of the container.
    absolute with relative
        for an absolute positioned element, remember it depends on the closest parent relative element
    creating custom Date with new Date() and methods 
        const date = new Date(event.date)
        {date.toLocaleDateString("en-US", {day: "2-digit"})}
        {date.toLocaleDateString("en-US", {month: "short"})}
        {new Date(event.date).toLocaleDateString("en-US", {weekday: "long", month: "long", day:"numeric"})}
    animations and transitions
        hover:scale[105] -> slightly bigger
        transition -> smooths out the effect
        active:scale-[1.02]
    aspects of page being navigation elements
        WRAP everything in LINK or ANCHOR
    overflow hidden uses
        sometimes overflow hidden can fix images or things going crazy and bigger
    z index requirements
        only elements relative absolute
    all elements static 
        by default every element is static, need to converrt to relative, absolute, fixed, sticky to use
            top,bottom,left,right,zindex
    color trick
        use same color with more oppacity for less important texts
    pattern of react components to reuse tags and stling for specific purposes
        Literally taking super serious reacts way of encapsulating html and making it reusable.
        Remember when something starts getting repetitive.

        Declaration
            function Section({children}: {children: React.ReactNode}) {
                return <section className="mb-12">{children}</section>
            }

            function SectionHeading({children}: {children: React.ReactNode}) {
                return <h2 className="mb-8 text-2xl">{children}</h2>
            }
        Usage
             <Section>
                <SectionHeading>About this event</SectionHeading>
                <p className="text-lg leading-8 text-white/75 max-w-4xl mx-auto">{event.description}</p>
            </Section>
    seeding db 
        populating with intial or test data
    advantages of abstracting fetch functions
        When switching db systems, it is insanely easier to to do. (bytegrad server -> local sqlite db file)
    advantages of server side pagination
        server manages all data and logic, client only receives. 
    
    
        

            
            
    

    







    
        

        
        
    
    

    
        
    
    
        
        
            


    
                


    
    
    
            

        



                    




        



        





        


-->
